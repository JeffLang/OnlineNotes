<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /* 
    js精度丢失问题：
      1.10进制转换为2进制
       整数十进制转二进制其实比较简单，就是将十进制的数不断除以2，直到结果是0。然后得到每一次的余数逆序汇总起来即可。
       小数部分的转换原则是将十进制的数不断乘以2，然后看得到的值是否大于1，如果大于1就收集一个1并且减去一个1，小于1就收集0，不断循环往复直到得到的是1，然后顺序排列就得到二进制的小数了。
       举例：0.625转换成为二进制的小数
        0.625 * 2 = 1.25 取出1，余下0.25 ------- 1
        0.25 * 2 = 0.5   取出0，余下0.5 -------- 0
        0.5 * 2 = 1      去除1，余下0   -------- 1
        顺序排列得到 .101 就是十进制的 0.625
        同理的将十进制的 0.1 转换为 二进制如下:
          0.1 x 2 = 0.2 小于1 收集 0
          0.2 x 2 = 0.4 小于1 收集 0
          0.4 x 2 = 0.8 小于1 收集 0
          0.8 x 2 = 1.6 大于1 收集 1 减掉1
          0.6 x 2 = 1.2 大于1 收集 1 减掉1
          0.2 x 2 = 0.4 小于1 收集 0
          0.4 x 2 = 0.8 小于1 收集 0
          0.8 x 2 = 1.6 大于1 收集 1 减掉1
          0.6 x 2 = 1.2 大于1 收集 1 减掉1
          0.2 x 2 = 0.4 小于1 收集 0
          0.4 x 2 = 0.8 小于1 收集 0
          0.8 x 2 = 1.6 大于1 收集 1 减掉1
          0.6 x 2 = 1.2 大于1 收集 1 减掉1
          0.2 x 2 = 0.4 小于1 收集 1
          ....

          得到的结果是0.000110011001100110011001100....
          会发现，这就陷入死循环了。

          如果空间无限，根据极限原理，二进制是可以无限接近十进制的0.1的。
    */
    // 定义一个函数,将十进制转换为二进制
    function decimalToBinary(decimal) {
      let binary = '';
      // 进制结束为整数部门为0 即在整数>0的时候进行运算
      while (decimal > 0) {
        // 获取余数
        binary = (decimal % 2) + binary;
        // 获取剩下的整数部分
        decimal = Math.floor(decimal / 2)
      }
      return binary
    }

    // 定义一个函数,将二进制转换为十进制
    function binaryToDecimal(binary) {
      let decimal = 0
      for (let i = 0; i < binary.length; i++) {
        decimal = decimal + (binary[i] * Math.pow(2, binary.length - 1 - i))
      }
      return decimal
    }

    // 定义一个函数，将十进制的小数部分转换为二进制的小数部分，需要两个参数，一个是十进制的小数，一个是转换位数限制
    function decimalToBinaryOfDecimal(decimal, precision = 12) {
      // 传入的绝对值小于1
      if (!(Math.abs(decimal) < 1)) return alert('请输入小数')
      // 先取出符号
      let binary = decimal > 0 ? '0.' : '-0.'
      decimal = Math.abs(decimal)
      // 判断是否达到终止条件：被处理后的数据 === 0，或者达到最大转换位数
      while (decimal > 0 && precision > 0) {
        // 十进制数据✖2
        decimal = decimal * 2
        // 判断整数位是否有1
        if (decimal >= 1) {
          binary += '1'
          decimal -= 1
        } else {
          binary += '0'
        }
        precision--
      }
      return binary
    }
    console.log(decimalToBinaryOfDecimal(0.625)) // 0.101
    console.log(decimalToBinaryOfDecimal(0.1, 100)) // 0.0001100110011001100110011001100110011001100110011001101

    // 定义一个函数，将二进制的小数转换为十进制小数点
    function binaryToDecimalOfDecimal(binary) {
      // 判断传入的值是否合法
      if (!(Math.abs(binary) < 1)) return alert('请传入合法的数字')
      // 初始化
      let decimal = 0;
      // 截取小数部分的数字
      const binaryStr = binary.toString().split('.')[1]
      for (let i = -1; i >= -(binaryStr.length); i--) {
        decimal += (+(binaryStr[-(i + 1)]) * Math.pow(2, i))
      }
      // 判断符号
      return binary < 0 ? -decimal : decimal
    }
    console.log(binaryToDecimalOfDecimal(-0.101))
  /* 
  js精度丢失
    使用 0.1 + 0.2 来进行举例
    o.1转化位二进制:
      0.0001100110011001100110011001100... 可以看到0.1转换为二进制的时候并不能完全进行转化,这个一个无线循环的过程
    0.2转换位二进制:
      0.0011001100110011001100110011001100... 0.2也是转化位二进制也是一个无限循环的
    从原理上来说，只要存储空间足够大，他们之间的转化就相等。
    
    在计算机读取十进制，转换为二进制的时候，就要将数字使用64位双精度储存在内存中
    0.1转换过程：
      科学记数法：1.10010011001100110011001100110011001100110011001100110*(2^-4) ，对应的指数位应该是 -4+1023（指数偏移量） = 1019  1019 => 01111111011
    符号位：0，正数
    指数位：01111111011，1019 => -4
    尾数位：1001100110011001100110011001100110011001100110011010，默认小数点前为1. 由于空间有限，只能展示52位，在此进行截取就会造成精度丢失

    0.2转换过程
      科学计数法：1.1001100110011001100110011001100110011001100110011010×(2^−3)，对应的指数位是1020 01111111011 + 1 = 01111111100
      符号位：0，正数
      指数位：01111111100
      尾数为：1001100110011001100110011001100110011001100110011010
    相加：
          0.0011001100110011001100110011001100110011001100110011010
          0.00011001100110011001100110011001100110011001100110011010
    0.3=> 0.010011001100110011001100110011001100110011001100110100 => 0.30000000000000004

    核心就是，由于js的number使用的是64双精度，储存的数字精度有限，而有些数字十进制转换为二进制的时候，会出现无限循环的情况，所以会被截断，截断后就会造成精度丢失

    指数偏移量：
      由于指数位由11位组成：所以能表示的数字范围为：[0,2047] 一共2048个数字
      而在表示js中他表示的指数范围为：[-1022, 1023] 一共2046个数字
      其中 指数位为: 00000000000 表示的是 0 这个数字 或者非规范化的数字
      指数位为: 11111111111 
        1.尾数为全为0,表示无穷大或者无穷小(取决于符号位)
        2.尾数不全为0,表示NaN.
    
  */
  </script>
</body>

</html>