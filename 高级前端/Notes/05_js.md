## 01、什么是防抖和节流，他们的应用场景有哪些

### 防抖(debounce)

触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

示例代码

```javascript
// 防抖: 高频事件n秒内只执行一次，结果是返回一个新的函数进行处理
function debounce(func, wait) {
  let timerId = 0
  return function () {
    // 进来就重新计时
    clearTimeout(timerId)
    // 保存this和参数
    const _this = this
    const args = arguments
    timerId = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
```

### 节流

针对高频事件n秒内只执行一次

示例代码

使用时间戳

```javascript
// 节流
function throttle(func, wait) {
  // 定义一个startTime
  let startTime = 0
  // 返回一个函数
  return function () {
    // 保存this和参数
    const _this = this
    const args = arguments
    // 记录本次的执行时间
    let nowTime = Date.now()
    // 判断,时间间隔达到之后在执行
    if (nowTime - startTime >= wait) {
      // 调用
      func.apply(_this, args)
      // 重置开始时间
      startTime = nowTime
    }
  }
}
```

使用定时器

```javascript
// 节流 定时器版本
function throttleTimer(func, wait) {
  let timerId = null
  return function () {
    const _this = this
    const args = arguments
    // 只有当没有定时器的时候才添加定时器
    if (!timerId) {
      timerId = setTimeout(() => {
        func.apply(_this, args)
        timerId = null
      }, wait)
    }
  }
}
```

## 02、手写Promise

```javascript
/*
            手写Promise

            思路

            */
// 定义三个状态的标记
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECT = 'reject'

class MyPromise {
  // 首先会生成一个promise对象
  // 定义一个私有状态变量,默认值为 pending
  #MyPromiseState = 'pending'
  // 定义一个返回结果 默认值为 undefined
  #MyPromiseResult = undefined

  // 定义一个保存then函数的数组,初始值为一个空的对象
  #ThenCallBackList = []
  // 定义一个保存去

  // 定义一个公共函数用来处理状态和结果,需要传入两个参数,state result
  #stateChange(state, result) {
    // 状态只能被修改一次,也就是说只能从pending
    if (this.#MyPromiseState !== PENDING) return
    this.#MyPromiseState = state
    this.#MyPromiseResult = result
    this.#run(state, result)
  }

  constructor(callBack) {
    // 定义resolve函数,调用该函数的时候,会修改promise对象的状态
    const resolve = data => {
      this.#stateChange(FULFILLED, data)
    }
    // 定义reject会修改promise的状态,
    const reject = result => {
      this.#stateChange(REJECT, result)
    }
    try {
      callBack(resolve, reject)
    } catch (error) {
      // 报错会直接调用reject
      console.error(`Uncaught (in myPromise) ${error}`)
      reject(error)
    }
  }

  // 定义一个run函数,用来执行then的回调
  #run(state, result) {
    // 从then回调列表中
    // 判断
    while (this.#ThenCallBackList.length) {
      const { onFulfilled, onReject, resolve, reject } = this.#ThenCallBackList.shift()
      try {
        // 执行这个函数,
        // 如果是fulfilled,执行onFulfilled
        if (state === FULFILLED) {
          resolve(onFulfilled(result))
        }
        // 如果是reject,执行onReject
        if (state === REJECT) {
          resolve(onReject(result))
        }
      } catch (error) {
        reject(error)
      }
    }
  }
  // 定义一个then函数
  // then函数
  // 1. then函数传入两个函数,第一个在resolve的时候调用,第二个在reject的时候调用
  // 2. then函数会返回一个promise
  then(onFulfilled, onReject) {
    return new MyPromise((resolve, reject) => {
      // 前一个promise resolve时调用onFulfilled
      if (this.#MyPromiseState === FULFILLED) {
        // then的回调是异步的
        setTimeout(() => {
          try {
            resolve(onFulfilled(this.#MyPromiseResult))
          } catch (error) {
            reject(error)
          }
        })
      }
      // 当前一个promise reject时,调用onReject
      if (this.#MyPromiseState === REJECT) {
        setTimeout(() => {
          try {
            resolve(onReject(this.#MyPromiseResult))
          } catch (error) {
            reject(error)
          }
        })
      }
      // 如果此时依然是pending状态,需要将这个传入一个then的回调队列中,等待到promise的状态确定之后在进行调用
      if (this.#MyPromiseState === PENDING) {
        // 把两个函数保存起来
        this.#ThenCallBackList.push({
          onFulfilled,
          onReject,
          resolve,
          reject,
        })
      }
    })
  }

  // 静态方法 resolve
  // 会返回一个promise对象,如果是Promise的实例,则调用该实例的then方法
  static resolve(value) {
    return new MyPromise((resolve, reject) => {
      // 如果是Promise对象,则调用这个promise对象的then方法
      if (value instanceof MyPromise) {
        // 调用这个thenable对象的then函数
        value.then(resolve, reject)
      } else {
        resolve(value)
      }
    })
  }

  // 静态方法 reject 返回一个拒绝的promise,不管是不是promise对象
  static reject(result) {
    return newMyPromise((_, reject) => {
      reject(result)
    })
  }

  // race方法,返回第一个完成的promise
  static race(promises) {
    return newMyPromise((resolve, reject) => {
      // 遍历传入的promise列表,因为只能执行一次,所以只会由第一个返回的promise状态
      promises.forEach(promise => {
        promise.then(result => resolve(result))
      })
    })
  }

  //Promise的静态方法，all
  static all(promises) {
    let values = []
    let i = 0
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        // 判断是否是promise
        if (promise instanceof MyPromise) {
          promise.then(
            value => {
              i++
              values[index] = value
              if (i >= promises.length) {
                resolve(values)
              }
            },
            result => {
              reject(result)
            },
          )
        } else {
          i++
          // 同步执行,肯定比上面快
          values[index] = promise
        }
      })
    })
  }
}
```

## 03、在前端开发中，如何获取浏览器的唯一标识

根据 `canvas` 可以获取浏览器指纹信息

1. 绘制 `canvas`，获取 `base64` 的 dataurl
2. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息

若在生产环境使用，可以使用 [fingerprintjs2(opens in a new tab)](https://github.com/Valve/fingerprintjs2)，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 `component`

## 04、js 中如何实现 bind

```javascript
// 手写apply,apply只是修改this
Function.prototype.myApply = function (context, ...args) {
  // 兼容性处理
  context = context || window
  // 保存this(函数本身)
  context.this = this
  // 调用
  const result = context.this(...args)
  delete context.this
  // 返回
  return result
}

// bind就是返回永久修改this的函数
Function.prototype.myBind = function (context, ...args) {
  const _this = this
  return function (...res) {
    return _this.myApply(context, [...args, ...res])
  }
}
```

## 05、js 中什么是 softbind，如何实现

```javascript
// bind就是返回永久修改this的函数
Function.prototype.mySoftBind = function (context, ...args) {
  const _this = this
  const bound = function (...res) {
    const newThis = !this || this === window ? context : this
    return _this.myApply(newThis, [...args, ...res])
  }
  bound.prototype = Object.create(_this.prototype)
  return bound
}
```

## 06、如何实现 promise.map，限制 promise 并发数

## 07、有没有用 npm 发布过 package，如何发布

1. 注册 npm 账号 [https://www.npmjs.com/(opens in a new tab)](https://www.npmjs.com/)
2. 本地通过命令行 `npm login` 登陆
3. 进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹

```json
{
  "name": "pkg-xxx",
  "version": "0.0.1",
  "main": "lib/index.js",
  "module": "esm/index.js",
  "typings": "types/index.d.ts",
  "files": [
    "CHANGELOG.md",
    "lib",
    "esm",
    "dist",
    "types",
  ],
  ...
}
```

执行 `npm publish --registry=https://registry.npmjs.org/` 即可发布

## 08、js 代码压缩 minify 的原理是什么

https://juejin.cn/post/7036169445550587940

## 09、关于 JSON，以下代码输出什么

对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉

## 10、在 js 中如何把类数组转化为数组

首先，什么是类数组(Array Like)？

**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**

那常见的类数组有哪些呢？

这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组

那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题

以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示

### ES6+

`ES6` 中有现成的 API：`Array.from`，极为简单

```javascript
// [undefined, undefined, undefined]
Array.from({ length: 3 });
```

除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值

拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代

```javascript
// 适用于 iterable 对象
[...document.querySelectorAll("div")];
```

但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常

```javascript
// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))[...{ length: 3 }];
```

### ES5

在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组

```javascript
const arrayLike = {  0: 3,  1: 4,  2: 5,  length: 3,};
```

在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。

最常见的转换是 `Array.prototype.slice`

```javascript
Array.prototype.slice.call(arrayLike);
```

**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**

- `Array` (借用 arguments)
- `Array.prototype.concat` (借用 arguments)
- `Array.prototype.slice` (借用 this)
- `Array.prototype.map` (借用 this)
- `Array.prototype.filter` (借用 this)

```javascript
Array.apply(null, arrayLike);
Array.prototype.concat.apply([], arrayLike);
Array.prototype.slice.call(arrayLike);
Array.prototype.map.call(arrayLike, (x) => x);
Array.prototype.filter.call(arrayLike, (x) => 1);
```

此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少

```javascript
// 该代码输出多少
Array(100).map((x) => 1);
```

> 参考 [Array(100).map(x =&gt; 1) 结果是多少(opens in a new tab)](https://github.com/shfshanyue/Daily-Question/issues/170)

### 稀疏数组 (sparse array)

使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示

`[,,,]` 与 `Array(3)` 都将返回稀疏数组

```javascript
> [,,,][empty × 3]> Array(3)[empty × 3]
```

当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组

### 总结

由上总结，把类数组转化成数组最靠谱的方式是以下三个

```javascript
Array.from(arrayLike);
Array.apply(null, arrayLike);
Array.prototype.concat.apply([], arrayLike);
```

以下几种方式需要考虑稀疏数组的转化

```javascript
Array.prototype.filter.call(divs, (x) => 1);
Array.prototype.map.call(arrayLike, (x) => x);
Array.prototype.filter.call(arrayLike, (x) => 1);
```

以下方法要注意是否是 `iterable object`

```javascript
[...arrayLike];
```

## 11、Array(100).map(x => 1) 结果是多少

`Array(100)` 将会创建一个稀疏数组 (sparse array)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`

```javascript
// [empty × 100]
Array(100);
```

正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`

**那如何生成100个元素为1的数组呢？**

可以使用 `Array.from`

```javascript
Array.from(Array(100), (x) => 1);
```

而在 `ES5` 中借用 `apply`

```javascript
Array.apply(null, Array(100)).map((x) => 1);
```

根据楼下提示，再添加一个 `fill`

```javascript
Array(100).fill(1);
```

## 12、如何在 url 中传递数组

转换为字符串在进行传递，或者是转成base64

## 13、compose函数

```javascript
const add10 = x => x + 10
const mul10 = x => x * 10
const add100 = x => x + 100

function compose1(...fns) {
  // 依次调用再返回
  return fns.reduce((a, b) => {
    return (...args) => {
      return a(b(...args))
    }
  })
}

function compose2(...fns) {
  return fns.reduce(
    (a, b) =>
    (...args) =>
    a(b(...args)),
  )
}

const fns = [add10, mul10, add100]

console.log(compose1(add10, mul10, add100)(10))
console.log(compose2(add10, mul10, add100)(10))
```

## 14、前端中遇到过处理二进制的场景吗

[JavaScript二进制数据处理(opens in a new tab)](http://coinfaces.me/posts/handling-binary-data-using-javascript/)

1. 读取二进制文件，绘制波形图。
2. 文件转储。下载文件，下载文件，后端返回二进制文件，前端进行处理并且下载

## 15、什么是 TypedArray

[ArrayBuffer，二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)

`ArrayBuffer` 是核心对象，是对固定长度的连续内存区域的引用。

几乎任何对 `ArrayBuffer` 的操作，都需要一个视图。

- 它可以是

  ```
  TypedArray
  ```

  ：

  - `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。
  - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。
  - `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。
  - `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。
- 或 `DataView` —— 使用方法来指定格式的视图，例如，`getUint8(offset)`。

在大多数情况下，我们直接对类型化数组进行创建和操作，而将 `ArrayBuffer` 作为“共同之处（common denominator）”隐藏起来。我们可以通过 `.buffer` 来访问它，并在需要时创建另一个视图。

还有另外两个术语，用于对二进制数据进行操作的方法的描述：

- `ArrayBufferView` 是所有这些视图的总称。
- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。

我们将在下一章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。

这是一份备忘单：

## 16、如何实现类似 lodash.get 函数

```javascript
function lodashGet(obj, path, defaultValue) {
  // 将a[3].b => a.3.b ,然后保存到数组中
  const paths = path.replace(/\[(\d+)\]/g, '.$1').split('.')
  // 层层迭代将
  const result = obj
  // 遍历paths依次拿值
  for (const key of paths) {
    result = Object(result)[key]
    if (result === undefined) {
      result = defaultValue
      break
    }
  }
  return result
}
```

## 17、js 中什么是可选链操作符，如何访问数组

`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。

```javascript
const o = {};

// 添加可选链之前
o && o.a && o.a.b && o.a.b.c && o.a.b.c.d;

// 添加可选链之后
o?.a?.b?.c?.d;
```

## 18、深拷贝

```javascript
// 深拷贝
function deepClone(obj, hash = new WeakMap()) {
  // 特殊值判断 null == undefined
  if (obj == null) return obj
  // Date,日期函数,正则等不拷贝
  if (obj instanceof Date) return obj
  if (obj instanceof RegExp) return obj
  if (typeof obj !== 'object') return obj
  if (has.get(obj)) return obj
  // 创建一个对象进行深拷贝
  const cloneObj = {}
  // 将当前对象保存到hash中
  hash.get(obj, cloneObj)
  for (const key in obj) {
    if (Object.hasOwnProperty.call(object, key)) {
      cloneObj[key] = deepClone(obj[key], hash)
    }
  }
  return cloneObj
}
```

## 19、event Loop

![image](https://user-images.githubusercontent.com/19162008/109372242-850c0980-78e3-11eb-8fe6-ecb15fa5e480.png)

heap（堆）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。 stack（栈）：函数调用形成了一个由若干帧组成的栈。 WebAPIS：囊括 Web 强大脚本能力的每个 API 参考资料， 包括 DOM 、所有相关的 APIs 及可以用来构建 Web 的相关接口。 队列（event queue || Callback Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数

[event loop 运行图解(opens in a new tab)](http://latentflip.com/loupe/?code=c2V0VGltZW91dChmdW5jdGlvbigpewogICAgY29uc29sZS5sb2coJzEnKQp9LDApOwoKbmV3oCBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpewoKoCBjb25zb2xlLmxvZygnMicpOwoKoCByZXNvbHZlKCk7Cgp9KS50aGVuKGZ1bmN0aW9uKCl7Cgpjb25zb2xlLmxvZygnMycpCgp9KTsKCmNvbnNvbGUubG9nKCc0Jyk7Cg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

```
setTimeout(() => {    console.log(1)}, 100)console.log(2);setTimeout(() => {    console.log(3)}, 0)// 2// 1// 3
```

![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif)

看图我们可以了解到，setTimeout(() => {console.log(1)}, 0) 会在Stack执行，在放入WebAPIs中当成一个匿名函数执行，匿名函数执行完毕之后会放入Callback Queue 中。 console.log(2) 则直接被推入Stack 中执行。

setTimeout(() => {console.log(3)}, 0) 同样的执行后放入WebAPIs中当成一个匿名函数执行，在放入Callback Queue中。当同步任务执行完之后，才会将Callback Queue 队列中的方法推入Stack中。

**因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。 所有同步任务都在主线程上执行，形成一个Stac）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才回读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。**

**这就是EventLoop**

## 20、flatMap实现

```javascript
// 先map再flat
const myFlatMap = function (fn) {
  const arr = this
  return arr.map(fn).flat(1)
}
```

## 21、裁切图片

```javascript
// 图片裁剪
function clipImage() {
  var path = 'https://static-zh.wxb.com.cn/customer/form/2020/11/1758696796d.jpg'
  // 创建一个canvas
  const canvas = document.createElement('canvas')
  canvas.width = 400
  canvas.height = 400
  // 获取ctx对象
  const ctx = canvas.getContext('2d')
  const img = document.createElement('img')
  const img2 = document.createElement('img')
  img.crossOrigin = 'anonymous'
  img.src = path
  document.body.appendChild(img)
  img.onload = function () {
    // 前面4个是源图片的位置及大小，后面是绘制在canvas的位置及大小
    // 如果只写了四个位置参数，则代表的是将整图片绘制在canvas上的位置大小，
    ctx.drawImage(this, 0, 0, 200, 200, 0, 0, 200, 200)
    console.log(canvas.toDataURL())
    const path = canvas.toDataURL()
    img2.src = path
    document.body.appendChild(img2)
  }
}
```

## 22、如何使用 async/await 实现 Promise.all 的效果

```javascript
async function fn() {
  const req = i =>
  fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=${i}&q=is%3Aissue+is%3Aopen`, {
    mode: 'no-cors',
  })

  // promise.all
  const res = await Promise.all([req(1), req(2), req(3)])

  // await
  const res1 = req(4)
  const res2 = req(5)
  const res3 = req(6)
  const u1 = await res1
  const u2 = await res2
  const u3 = await res3
  }
fn()
```

## 23、有没有用过 Promise.allSettled() ，它是干什么的

接收一个可迭代对象，其中每个成员都是 `Promise`。在所有给定的 `Promise`都已经 `fulfilled`或 `rejected`后返回一个 `Promise`，并带有一个对象数组，每个对象表示对应的 `Promise`结果 相较于 `Promise.all`，后者会在任何一个 `Promise`为 `rejected`时立即结束 简单实现

## 24、如何查看你们 JS 项目中应采用的 node 版本

我不确定是指 一个完全新的从零开始的项目，还是指已有的项目相对于新人来说的刚接手的“新”。

1. 如果是一个完全新的从零开始的项目，一般来说，如果均是采用最新稳定版本的依赖包，那么可以采用的node版本，其范围可以确定在 `^14.18.0 || >=16` 不超过node的当前最新稳定版本；而如果由于项目的特殊性，采用了低版本的依赖包，那么需要查看这些包的 `package.json` 的 `engines.node` 以确定这些包支持的node版本，取交集后确定最终采用的node版本。
2. 如果是一个已有的项目，首先查看的是 项目的 `package.json` 中的 `engines.node` 字段，如果有声明，那么就采用对应的版本，如果没有，那么直接询问该项目的原负责人，确认是否有 node 版本的要求以及应该使用哪个版本，负责人不确定就询问原先用于开发或构建这个项目的机器安装的 node 版本，这样可以保证切换到新人的开发机器上，也有一致的node环境。

## 25、简述 node/v8 中的垃圾回收机制

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。 要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。 **代际假说（The Generational Hypothesis）**，是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。 代际假说有以下两个特点：

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
2. 是不死的对象，会活得更久。 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。 ● **副垃圾回收器**，主要负责新生代的垃圾回收。 ● 主垃圾回收器，主要负责老生代的垃圾回收。

全停顿![1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f](https://user-images.githubusercontent.com/19986739/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png)

增量标记![1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97](https://user-images.githubusercontent.com/19986739/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，增强用户体验。

参考： [浏览器工作原理与实践](https://time.geekbang.org/column/article/131233)

## 26、fetch 中 credentials 指什么意思，可以取什么值

`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`

- `omit`: 从不发送 `cookie`.
- `same-origin`: 同源时发送 `cookie` (浏览器默认值)
- `include`: 同源与跨域时都发送 `cookie`

## 27、如何删除项目中没有使用到的 package

```shell
$ npm install depcheck -g

$ depcheck
Unused dependencies
* underscore
Unused devDependencies
* jasmine
Missing dependencies
* lodash
```

## 28、如何实现 Promise.race

**`Promise.race()`** 静态方法接受一个 promise 可迭代对象作为输入，并返回一个 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。这个返回的 promise 会随着第一个 promise 的敲定而敲定。

## 29、js 中在 new 的时候发生了什么

1. 创建了一个新对象
2. 链接到原型
3. 绑定this指向4.返回这个对象

## 30、什么是 Iterable 对象，与 Array 有什么区别

- iterable对象是符合迭代器接口，可以通过 iterable.next()或者 for of 访问其中的元素
- Array是特殊的iterable对象，除了itearable的方式不遍历外，还 提供了 for in foreach map等方式

```javascript
// 数组的迭代器对象
const arr = [1, 2, 3, 4, 5]
let rangeArr = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  4: 5,
}

// 1. for..of 调用首先会调用这个：
rangeArr[Symbol.iterator] = function () {
  // 获取最多的迭代器的时常
  const keys = Object.keys(rangeArr)
  let i = 0
  let len = keys.length
  // ……它返回迭代器对象（iterator object）：
  // 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值
  return {
    // 3. next() 在 for..of 的每一轮循环迭代中被调用
    next() {
      // 4. 它将会返回 {done:.., value :...} 格式的对象
      if (i < len) {
        // return { done: false, value: { key: keys[i], value: rangeArr[keys[i++]] } } // 对象类的返回方法,
        return { done: false, value: rangeArr[keys[i++]] } // 数组类的返回方法
      } else {
        return { done: true }
      }
    },
  }
}

// arr[Symbol.iterator] = null // 如果执行此行,则arr也不能使用for...of进行遍历

for (const iterator of rangeArr) {
  console.log('iterator', iterator)
}

console.dir(arr[Symbol.iterator]().next()) // 可通过此方式访问next()

for (const iterator of arr) {
  console.log('iterator', iterator)
}
```

## 31、js 如何全部替代一个子串为另一个子串

如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag

```
const s = "foo foo foo";s.replce(/foo/g, "bar");
```

那如题中，**是否可以使用正则表达式来替代子串**

答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下

```
// 期待结果: 'AhelloX hello3 '> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')< "AAA"
```

而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`

```
> 'hello. hello. hello. '.split('hello. ').join('A')< "AAA"
```

真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中

```
String.prototype.replaceAll(); "aabbcc".replaceAll("b", ". 'aa..cc'
```

详细文档在 [String.prototype.replaceAll(opens in a new tab)](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)

### 总结(及直接答案)

两种办法

- `str.split('foo').join('bar')`
- `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好

正则表达式中有特殊字符的话，可以将其转译：

```javascript
>  'hello. helloX hello3 '.replace(new RegExp('hello\\. ', 'g'), 'A')
< "AhelloX hello3 "
```

## 32、js如何实现继承

有以下两种方法可实现继承

### `class`/`extends`

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  hello() {
    console.log("hello");
  }
}

class Dog extends Animal {
  constructor(name, say) {
    super(name);
    this.say = say;
  }
}
```

### `function`/`new`

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.hello = () => {
  console.log("hello");
};

function Dog(name, say) {
  // 01 继承属性
  Animal.call(this, name);
  this.say = say;
}

// 02 通过连接原型链完成继承
Dog.prototype = Object.create(Animal.prototype);

// 03 再加上 constructor
Dog.prototype.constructor = Dog;
// Reflect.defineProperty(Dog.prototype, "constructor", {
//  value: Dog,
//  enumerable: false, // 不可枚举
//  writable: true
// })
```

## 33、once函数

```javascript
function once(fn) {
  // 定义一个flag,判断是否调用过
  let flag = false
  const argsObj = {}
  // 会返回一个函数
  return function (...arg) {
    // 判断函数是否被执行了
    const key = JSON.stringify(arg)
    if (flag && argsObj[key]) return argsObj[key]
    flag = true
    return (argsObj[key] = fn.apply(this, arg))
  }
}
// 测试
function test() {
  console.log('test')
  return 1
}
let o = once(test)
console.log(o()) // test 1
console.log(o()) // 1
console.log(o()) // 1
```

## 34、纯函数

通过 `Object`构造函数创建或 `__proto__`是 `null`

`Object.create(null)`

## 35、累加器

```javascript
function sum(...args) {
  // 返回一个函数继续收集参数
  const fn = (...reset) => sum(...args, ...reset)
  // 这个函数拥有一个valueOf属性
  fn.valueOf = () => {
    return args.reduce((prev, now) => {
      return (prev += now)
    })
  }
  return fn
}
```

## 36、JS 如何实现一个同步的 sleep 函数

```javascript
const sleepSync = wait => {
  const endTime = Date.now() + wait
  while (Date.now() < endTime) {}
}
```

## 37、实现一个函数用来解析 URL 的 querystring

```javascript
// 使用正则来进行
function parseUrl(url = window.location.href) {
  // 获取search 是一个字符串,
  const search = url.match(/\?([^?/#:]+)#?/)?.[1]
  const params = search.split('&').reduce((prev, now) => {
    let [key, val] = now.split('=')
    // 转义
    key = decodeURIComponent(key)
    val = decodeURIComponent(val)
    // 判断是否有相同的参数
    if (prev[key] !== undefined) {
      prev[key] = [].concat(prev[key], val)
    } else {
      prev[key] = val
    }
    return prev
  }, {})
  }
```

一开始 `decodeURIComponent(url)`是否不妥，如果query string中的value带有 `=`等字符并且已经被 `encodeURIComponent`，如 `http://example.com?tag=test&title=1%2B1%3D2`中 `title=1+1=2`，使用parse解析的结果是错误的。使用 `params[k] = decodeURIComponent(v)`是不是更好

## 38、delay

```javascript
function delay1(func, seconds, ...args) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const p1 = Promise.resolve(func(...args))
      .then(resolve)
      .catch(reject)
      }, seconds)
  })
}
function delay2(func, seconds, ...args) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        resolve(func(...args))
      } catch (error) {
        reject(error)
      }
    }, seconds)
  })
}
```

## 39、如何实现一个 sample 函数，从数组中随机取一个元素

```javascript
Array.prototype.sample = function () {
  return this[Math.floor(Math.random() * this.length)];
};
```

## 40、浏览器的剪切板中如何监听复制事件

在HTML元素上

```html
<input oncopy="cb" />
```

在JS中获取具体元素

```javascript
document.querySelector("p").oncopy = cb;document.oncopy = cb;
```

或者

```javascript
document.querySelector("p").addEventListener("copy", cb);document.addEventListener("copy", cb);
```

## 41、JSONP 的原理是什么，如何实现

摘自山月的博客，原文地址: [https://shanyue.tech/code/jsonp/(opens in a new tab)](https://shanyue.tech/code/jsonp/)

### 一个正常的请求: JSON

正常发请求时，`curl` 示例:

```javascript
$ curl https://shanyue.tech/api/user?id=100
 
{
  "id": 100,
  "name": "shanyue",
  "wechat": "xxxxx" ,
  "phone": "183xxxxxxxx"
}
```

使用 `fetch` 发送请求，示例:

```javascript
const data = await fetch("https://shanyue.tech/api/user?id=100", {
  headers: {
    "content-type": "application/json",
  },
  method: "GET",
}).then((res) => res.json());
```

请求数据后，使用一个函数来处理数据

```javascript
handleData(data);
```

### 一个 JSONP 请求

`JSONP`，全称 `JSON with Padding`，为了解决跨域的问题而出现。虽然它只能处理 GET 跨域，虽然现在基本上都使用 CORS 跨域，但仍然要知道它，毕竟**面试会问**。

`JSONP` 基于两个原理:

1. 动态创建 `script`，使用 `script.src` 加载请求跨过跨域
2. `script.src` 加载的脚本内容为 JSONP: 即 `PADDING(JSON)` 格式

从上可知，使用 `JSONP` 跨域同样需要服务端的支持。`curl` 示例

```javascript
$ curl https://shanyue.tech/api/user?id=100&callback=padding

padding({
  "id": 100,
  "name": "shanyue",
  "wechat": "xxxxx",
  "phone": "183xxxxxxxx"
})
```

对于正常的请求有何不同一目了然: **多了一个 callback=padding, 并且响应数据被 padding 包围**，这就是 JSONP

**那请求数据后，如何处理数据呢？此时的 padding 就是处理数据的函数**。我们只需要在前端实现定义好 padding 函数即可

```javascript
window.padding = handleData;
```

基于以上两个原理，这里实现一个简单 jsonp 函数：

```javascript
function jsonp_simple({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、默认 callback 函数为 padding
  script.src = `${url}?${stringify({ callback: "padding", ...params })}`;

  // 二、使用 onData 作为 window.padding 函数，接收数据
  window["padding"] = onData;

  // 三、动态加载脚本
  document.body.appendChild(script);
}

// 发送 JSONP 请求
jsonp_simple({
  url: "http://localhost:10010",
  params: { id: 10000 },
  onData(data) {
    console.log("Data:", data);
  },
});
```

此时会有一个问题: **window.padding 函数会污染全局变量，如果有多个 JSONP 请求发送如何处理？**

**使 jsonp 的回调函数名作为一个随机变量，避免冲突**，代码如下

```javascript
function jsonp({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、为了避免全局污染，使用一个随机函数名
  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`;

  // 二、默认 callback 函数为 cbFnName
  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`;

  // 三、使用 onData 作为 cbFnName 回调函数，接收数据
  window[cbFnName] = onData;

  document.body.appendChild(script);
}

// 发送 JSONP 请求
jsonp({
  url: "http://localhost:10010",
  params: { id: 10000 },
  onData(data) {
    console.log("Data:", data);
  },
});
```

#### 服务器端代码

`JSONP` 需要服务端进行配合，返回 `JSON With Padding` 数据，代码如下:

```javascript
const http = require("http");
const url = require("url");
const qs = require("querystring");

const server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url);
  const params = qs.parse(query);

  const data = { name: "shanyue", id: params.id };

  if (params.callback) {
    // 服务端将要返回的字符串
    str = `${params.callback}(${JSON.stringify(data)})`;
    res.end(str);
  } else {
    res.end();
  }
});

server.listen(10010, () => console.log("Done"));
```

#### 完整代码附录

完整代码可见[山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code): [https://github.com/shfshanyue/blog/tree/master/code/jsonp/(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code/jsonp/)

**JSONP 实现完整代码:**

```javascript
function stringify(data) {
  const pairs = Object.entries(data);
  const qs = pairs
  .map(([k, v]) => {
    let noValue = false;
    if (v === null || v === undefined || typeof v === "object") {
      noValue = true;
    }
    return `${encodeURIComponent(k)}=${noValue ? "" : encodeURIComponent(v)}`;
  })
  .join("&");
  return qs;
}

function jsonp({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、为了避免全局污染，使用一个随机函数名
  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`;
  // 二、默认 callback 函数为 cbFnName
  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`;
  // 三、使用 onData 作为 cbFnName 回调函数，接收数据
  window[cbFnName] = onData;

  document.body.appendChild(script);
}
```

**JSONP 服务端适配相关代码:**

```javascript
const http = require("http");
const url = require("url");
const qs = require("querystring");

const server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url);
  const params = qs.parse(query);

  const data = { name: "shanyue", id: params.id };

  if (params.callback) {
    str = `${params.callback}(${JSON.stringify(data)})`;
    res.end(str);
  } else {
    res.end();
  }
});

server.listen(10010, () => console.log("Done"));
```

**JSONP 页面调用相关代码**

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title></title>
  </head>
  <body>
    <script src="./index.js" type="text/javascript"></script>
    <script type="text/javascript">
      jsonp({
        url: "http://localhost:10010",
        params: { id: 10000 },
        onData(data) {
          console.log("Data:", data);
        },
      });
    </script>
  </body>
</html>
```

### JSONP 实现代码示例演示

- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)
- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)
- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)

#### 文件结构

- `index.js`: jsonp 的简单与复杂实现
- `server.js`: 服务器接口形式
- `demo.html`: 前端如何调用 JSONP

#### 快速演示

```nginx
// 开启服务端
$ node server.js

// 对 demo.html 起一个服务，并且按照提示在浏览器中打开地址，应该是 http://localhost:5000
// 观察控制台输出 JSONP 的回调结果
$ serve .
```

## 42、v8是如何执行一段js代码的

### 参考几篇文章

- [V8是如何执行JavaScript代码的？](https://zhuanlan.zhihu.com/p/96502646)
- [[译\]JavaScript是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧](https://zhuanlan.zhihu.com/p/57898561)
- [JavaScript 引擎 V8 执行流程概述](https://zhuanlan.zhihu.com/p/111386872)

## 43、实现一个数组去重函数 unique

- 使用Set

```javascript
function unique(arr) {
  if (!Array.isArray(arr)) throw new TypeError();
  return [...new Set(arr)];
}
```

- 使用set

```javascript
// 使用Map方法
function unique2(arr) {
  // 判断,如果传的不是数组则需要直接返回
  if (!Array.isArray(arr)) return
  const map = new Map()
  // 使用map进行去重
  for (const val of arr) {
    map.set(val, val)
  }
  const list = []
  for (const val of map.keys()) {
    list.push(val)
  }
  return list
}
```

## 44、shuffle

使用以下算法可实现洗牌算法:

1. 第 N 项数字与前 N 项数字随机选一相互交换
2. 第 N-1 项数字与前 N-1 项数字随机选一相互交换
3. ...
4. 第 2 项数字与前 2 项数字随机选一相互交换

```javascript
// 从后面开始打乱
function shuffle1(list) {
  const len = list.length
  let result = [...list]
  for (let i = len - 1; i > 0; i--) {
    const swapIndex = Math.floor(Math.random() * (i + 1))
    console.log(i, swapIndex)
    ;[result[i], result[swapIndex]] = [result[swapIndex], result[i]]
  }
  return result
}

// 从前面开始打乱
function shuffle2(list) {
  const len = list.length
  let result = [...list]
  for (let i = 0; i < len - 1; i++) {
    // 选择从1到length选中一个进行交换
    const swapIndex = Math.floor(Math.random() * (len - (i + 1))) + (i + 1)
    ;[result[i], result[swapIndex]] = [result[swapIndex], result[i]]
  }
  return result
}
```

## 45、vue3 中，如何监听数组的变化

不需要额外监听，因为 Proxy 代理后的数据，数组的修改也是可以监听到的，reactive 之后直接修改即可。

let list = [] const listProxy = new Proxy(list, { set(target, property, value) { console.log('set', property, value) //property指下标 value值 target[property] = value return true //表示设置成功 } })

## 46、现代框架如 React、Vue 相比原生开发有什么优势

react、vue： 1、一套代码维护Android和ios两个平台，减少开发成本 2、相同功能可以使用组件复用 3、两个平台可以同时更新，原生代码更新时需要审核

## 47、typeof 与 instanceof 的区别

1. `typeof` 用以**判断基础数据类型** (null 除外)，对于引用数据类型，大部分都是返回的Object
2. `instanceOf` 借助原型链**判断复杂数据类型**，但是值不确定

`typeof` 能够准确检查除了 null 之外的基础数据类型(number, string, symbol, bigInt, undefined, boolean, null)

`instanceof` 的语义是检查操作符右边的函数原型是否存在于左边对象的原型链中

## 48、JS 如何翻转一个字符串

```javascript
const reverse = (s) => [...s].reduceRight((acc, cur) => acc + cur);
const reverse = (s) => s.split("").reverse().join("");
```

## 49、前端如何实现文件上传功能

```javascript
const uploadInput = document.getElementById("upload");
const handleUpload = (event) => {
  const file = event.target.files[0];
  const formData = new FormData();
  formData.append("file", file);
  // 文件上传操作
};
uploadInput.addEventListener("change", handleUpload);
```

## 51、Promise.all

```javascript
//Promise的静态方法，all,any正好相反
static all(promises) {
  let values = []
  let i = 0
  return new MyPromise((resolve, reject) => {
    promises.forEach((promise, index) => {
      // 判断是否是promise
      if (promise instanceof MyPromise) {
        promise.then(
          value => {
            i++
            values[index] = value
            if (i >= promises.length) {
              resolve(values)
            }
          },
          result => {
            reject(result)
          },
        )
      } else {
        i++
        // 同步执行,肯定比上面快
        values[index] = promise
      }
    })
  })
}
```

## 51、Promise.any

与Promise.all相反

## 52、如何过滤数组中的 falsy value

falsy value 包含：`false`, `null`, `0`, `""`, `undefined`, `NaN`

## 53、如何创建一个数组大小为100，每个值都为0的数组

```javascript
// 方法一:
Array(100).fill(0);

// 方法二:
// 注: 如果直接使用 map，会出现稀疏数组
Array.from(Array(100), (x) => 0);

// 方法二变体:
Array.from({ length: 100 }, (x) => 0);
```

## 54、async await原理

### Generator

async/await为什么说是语法糖呢，是谁的语法糖呢？

在阮一峰的ES6入门教程中有说到：

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

> Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。
>
> 异步操作需要暂停的地方，都用 yield 语句注明
>
> 调用 Generator 函数，返回的是指针对象(这是它和普通函数的不同之处),。调用指针对象的 next 方法，会移动内部指针。
>
> next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

了解generator用法

```javascript
function* Generator() {
  yield "1";
  yield Promise.resolve(2);
  return "3";
}
var gen = Generator();
console.log(gen); //返回一个指针对象 Generator {<suspended>}
```

调用next方法

```javascript
let res1 = gen.next();
console.log(res1); // 返回当前阶段的值 { value: '1', done: false }

let res2 = gen.next();
console.log(res2); // 返回当前阶段的值 { value: Promise { 2 }, done: false }

res2.value.then((res) => {
  console.log(res); // 2
});

let res3 = gen.next();
console.log(res3); // { value: '3', done: true }

let res4 = gen.next();
console.log(res4); // { value: undefined, done: true }
```

### 实现async/await

**async/await的理解**

- **async 函数执行结果返回的是一个Promise**
- **async 函数就是将 Generator 函数的星号（\*）替换成 async，将 yield 替换成await**
- **async/await 就是 Generator 的语法糖，其核心逻辑是迭代执行next函数**

先来初步实现一个执行结果返回Promise的函数

先来初步实现一个执行结果返回Promise的函数

```javascript
function muYouAsync(){
      // 返回一个函数
    return function(){
          // 返回一个promise
        return new Promise((resolve, reject) => {

        })
    }
}
```

并且呢muYouAsync接受一个Generator函数作为参数的，那我们再来完善一下

```javascript
function* gen() {

}
//接受一个Generator函数作为参数
function muYouAsync(gen){
      // 返回一个函数
    return function(){
          // 返回一个promise
        return new Promise((resolve, reject) => {

        })
    }
}
```

我们来测试下看下执行结果是否返回Promise

```javascript
const asyncGen = muYouAsync(gen)
console.log(asyncGen()) //Promise {<pending>}
```

看输出结果的话与执行结果返回Promise是一致的

至此呢第一部分函数执行返回结果已完成，那我们来完善一下Generator函数

```javascript
const getFetch = (nums) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(nums + 1);
    }, 1000);
  });

function* gen() {
  let res1 = yield getFetch(1);
  let res2 = yield getFetch(res1);
  let res3 = yield getFetch(res2);
  return res3;
}
```

Generator函数也编写完成了，在下一步我们要想，怎么让它执行起来了呢，那就需要用到Generator核心逻辑迭代执行next函数，**注意点是需要将next迭代执行**

```javascript
//接受一个Generator函数作为参数
function muYouAsync(gen) {
  // 返回一个函数
  return function () {
    // 返回一个promise
    return new Promise((resolve, reject) => {
      // 执行Generator函数
      let g = gen();
      const next = (context) => {
        const { done, value } = g.next(context);
        if (done) {
          // 这时候说明已经是完成了，需要返回结果
          resolve(value);
        } else {
          // 继续执行next函数,传入执行结果
          return Promise.resolve(value).then(val => next(val))
        }
      };
      next();
    });
  };
}
```

整体的逻辑已经全都补充好了，那我们还需要在完善下最后一步，async返回的是promise，所以我们可以用try catch 来捕获

### 完整代码

```javascript
// 实现一个自动执行generator函数的方法

// 此函数需要接受一个gen函数作为参数
function autoGenerator(gen) {
  // 此函数返回一个函数
  return function () {
    // async函数调用会返回一个promise对象
    return new Promise((resolve, reject) => {
      // 通过这个generator实例类进行next的调用
      const g = gen()
      // 定义一个自动调用next方法的函数,需要传递一个值,用于这个generator指针对象的返回值
      const autoNext = context => {
        // 获取next的值,yield后面调用的函数通过next来传递参数
        const { value, done } = g.next(context) // 最后一次next的值是由generator的返回值确定的
        // 判断是否已经执行完成
        if (done) {
          return resolve(value)
        } else {
          // 继续调用
          return Promise.resolve(value).then(
            res => autoNext(res),
            err => autoNext(err),
          )
        }
      }
      autoNext()
    })
  }
}
```

那我们最后来测试一下

```javascript
const getFetch = (nums) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(nums + 1);
    }, 1000);
  });

function* gen() {
  let res1 = yield getFetch(1);
  let res2 = yield getFetch(res1);
  let res3 = yield getFetch(res2);
  return res3;
}

const asyncGen = muYouAsync(gen);
asyncGen().then(res => {console.log(res)}); // 4
```

## 55、Map 与 WeakMap 有何区别

`WeakMap `与 `Map `在 API 上的区别主要是两个，一是没有遍历操作（即没有 `keys()`、`values()`和 `entries()`方法），也没有 `size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 `clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`

## 56、Javascript 数组中有那些方法可以改变自身，那些不可以

不改变原数组的方法：concat/join/reduce/map/forEach/filter/slice/findIndex

改变原数组的方法：push/unshift/pop/shift/sort/splice/reverse

## 57、如何判断一个数组是否包含某个值

`Array.prototype.includes`

## 58、如何判断字符串包含某个子串

`String.prototype.includes();`

## 59、如何判断某一个值是数组

`const isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'`

## 60、简述 Object.defineProperty

与直接为一个对象的属性赋值(`o.a = 3`)不同，`Object.defineProperty` 可更为精确，拥有更多选项地为对象属性赋值

属性描述符拥有两种: 数据描述符与存取描述符

### 数据描述符 (data descriptor)

决定该属性值是否可写

```
const o = {};Object.defineProperty(o, "a", {  configurable: false,  enumerable: false,  writable: true,  value: 3,});
```

- `configurable`: 是否可被删除
- `enumerable`: 是否可被枚举，不可枚举属性无法通过 `Object.keys` 获取到
- `writable`: 是否可更改该属性值
- `value`: 该属性值的值

当我们使用赋值运算符为对象添加属性时，实际上是添加了一个数据描述符

```
> o.c = 5> Object.getOwnPropertyDescriptor(o, 'c')< {value: 5, writable: true, enumerable: true, configurable: true}
```

### 存取描述符 (accessor descriptor)

可对对象属性进行拦截，Vue2 的数据绑定原理便是基于此

```
const o = {};Object.defineProperty(o, "a", {  configurable: false,  enumerable: false,  get() {    return this._a;  },  set(a) {    this._a = a * 10;  },});
```

如果描述符没有 `value`、`writable`、`get` 和 `set` 键中的任何一个，它将被视为数据描述符。如果描述符同时具有 [`value` 或 `writable`] 和 [`get` 或 `set`] 键，则会抛出异常。

## 61、实现一个 inherits 函数进行继承

```javascript
function inherits(SuperType, SubType) {
  const pro = Object.create(SuperType.prototype);
  pro.constructor = SubType;
  SubType.prototype = pro;
}
function SuperType(friends) {
  this.friends = friends;
}
SuperType.prototype.getFriends = function () {
  console.log(this.friends);
};
function SubType(name, friends) {
  this.name = name;
  SuperType.call(this, friends);
}
inherits(SuperType, SubType);
SubType.prototype.getName = function () {
  console.log(this.name);
};

const tom = new SubType("tom", ["jerry"]);
tom.getName();
// 'tom'
tom.getFriends();
// ['jerry']
tom.friends.push("jack");
tom.getFriends();
// ['jerry', 'jack']
```

## 62、WeakMap 与垃圾回收有何关系

`WeakMap` 与 `Map` 有亮点不同

1. 键值只能为引用对象，无法使用基础数据类型
2. 弱引用，无法枚举，因此无 `.entries()` 方法

WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

## 63、什么是媒体查询，JS 可以监听媒体查询吗

![image](https://user-images.githubusercontent.com/101323067/188387499-1c5b9091-f7f6-40c0-98ca-e176ab474389.png)

js也支持媒体查询，window. matchMedia()方法，参考文章：[https://cloud.tencent.com/developer/article/2061082(opens in a new tab)](https://cloud.tencent.com/developer/article/2061082)

## 64、关于块级作用域，以下代码输出多少，在何时间输出

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000);}
```

一秒之后连续输出五个5，以下可输出预期效果

```
for (let i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000 * i);} for (var i = 0; i < 5; i++) {  setTimeout(console.log, 1000 * i, i);}
```

> 一秒之后连续输出五个5，以下可输出预期效果
>
> ```javascript
> for (let i = 0; i < 5; i++) {
>   setTimeout(() => console.log(i), 1000 * i);
> }
>  
> for (var i = 0; i < 5; i++) {
>   setTimeout(console.log, 1000 * i, i);
> }
> ```

为什么setTimeout格式不同,输出的结果也不同.例如:当for循环采用var声明变量,但setTimeout(console.log,1000*i,i)与setTimeout(()=>console.log(i),0)输出的结果不一样.

是因为函数作用域?

第一种使用var的方式:

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000);}
```

第二种使用var的方式:

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(console.log, 1000 * i, i);}
```

var 声明的变量是在函数作用域或者全局作用域的，在第一种方式中，由于setTimeout是异步执行，且它是从闭包中获取 i 变量，由于 i 是在函数/全局作用域中声明的，所以5次循环中 i 不断被赋值，最后 i 的值为5，执行的结果为连续的5个5。

在第二种方式中，通过给setTimeout的回调函数传参的方式，保存了每次循环中 i 的值，因此执行结果符合预期

let声明的变量是在块级作用域(花括号)中的，因此可以认为每次执行循环语句块中的 i 变量是互相独立的，所以执行结果也符合预期

## 65、关于块级作用域，以下代码输出多少，在何时间输出

可以直接调用 API 进行实现:

```javascript
const reverse = (s) => s.split("").reverse().join("");
 
reverse("hello");
//=> "olleh"
```

如果不调用 API 实现的话，参考以下代码:

```javascript
function reverse(s) {
  let r = "";
  for (const c of s) {
    r = c + r;
  }
  return r;
}
 
reverse("hello");
//=> "olleh"
```

## 66、为何 0.1+0.2 不等于 0.3，应如何做相等比较

0.1，0.2 表示为二进制会有精度的损失，比较时可引入一个很小的数值 `Number.EPSILON` 容忍误差

`Number.EPSILON` 是数字中 1 和可表示的比 1 大的最小数字之间的差值，因为[双精度浮点格式](https://zh.wikipedia.org/wiki/雙精度浮點數)只有 52 位来表示[尾数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_编码)，并且最低位的有效值为 2-52。

请注意，浮点数的绝对精度随着数字变大而降低，因为指数增长而尾数的精度保持不变。[`Number.MIN_VALUE`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE) 是可表示的最小正数，远小于 `Number.EPSILON`。

然而，对于任何具有更大数量级的算术运算，`Number.EPSILON` 是不适用的。如果你的数据数量级在 10**3 的范围，那么小数部分的精确度将远远小于 `Number.EPSILON`：

```javascript
function equal(x, y) {
  return Math.abs(x - y) < Number.EPSILON;
}

const x = 0.2;
const y = 0.3;
const z = 0.1;
console.log(equal(x + z, y)); // true
```

### 说说 Javascript 数字精度丢失的问题，如何解决？

`javaScript`存储方式是双精度浮点数，其长度为8个字节，即64位比特

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023，二进制1.0的指数位就是1023（转化为二进制）
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

如下图所示：

![594f0f0db0bd45779f3cfeb0147a9e46](https://static.developers.pub/594f0f0db0bd45779f3cfeb0147a9e46.png)

## 67、什么是纯函数

1. 输出仅由输入决定，每一个固定的输入总是返回相同的输出
2. 不产生副作用

```javascript
function push(list, x) {
  list.push(x);
  return list;
}

const l = [];
push(l, 3);
```

## 68、数字添加千分符

```javascript
function numberThousands(num, sign = ',') {
  return num.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, `$1${sign}`)
}
```

## 69、深比较deepEqual

```javascript
// 不光只判断对象的内存地址,还需要判断内部的内容是否相等
function deepEqual(x, y) {
  // 首先判断两个对象是都相等
  if (x === y) return true
  // 判断对象
  if (typeof x === 'object' && x !== null && typeof y === 'object' && y !== null) {
    // 进行递归比较
    // 先获取keys
    const xKeys = Object.keys(x)
    const yKeys = Object.keys(y)
    // 如果key的长度都不相等,肯定整个对象也不相等
    if (xKeys.length !== yKeys.length) return false
    // 遍历数组进行比较,只要遇到一个不相等则肯定不等
    for (const key of xKeys) {
      if (!deepEqual(x[key], y[key])) {
        return false
      }
    }
    // 如果整个for...of没找到不同,则返回true
    return true
  }
  console.log('else')
  return false
}
```

## 70、Object.is 与全等运算符(===)有何区别

Object.is()在===基础上特别处理了NaN,-0,+0，保证-0与+0不相等，但NaN与NaN相等

## 71、js 中什么是 AsyncIterable

```javascript
for await (const x of data) {
}
```

异步可迭代对象（Streams）

## 72、了解什么是 JSBridge 吗

而JSBridge是H5与Native的通信桥梁，他允许H5去调用原生的api（比如拍照、截屏、录屏等），极大的拓展了H5功能。

## 73、使用 JS 如何生成一个随机字符串

```javascript
// 生成随机字符串
function radomString(length = 32) {
  const str = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678',
        strLength = str.length
  let result = ''
  for (let index = 0; index < length; index++) {
    result += str.charAt(Math.random() * strLength)
  }
  return result
}
console.log(radomString())
```

## 74、Number.isNaN 与 globalThis.isNaN 有何区别

```javascript
// Number.isNaN 不会对数据进行类型转换
console.log('Number.isNaN', Number.isNaN('NaN')) // false

// globalThis.isNaN 会对数据进行类型转换
console.log('globalThis.isNaN', globalThis.isNaN('NaN')) // true
```

## 75、如何判断一个数值为整数

### Number.isFinite()

**`Number.isFinite()`** 静态方法判断传入值是否是一个有限数——也就是说，它检查给定值是一个数字，且该数字既不是正的 [`Infinity`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity)，也不是负的 `Infinity` 或 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。

### Number.isInteger()

**`Number.isInteger()`** 静态方法判断传入值是否为整数。

### Number.isSafeInteger()

**`Number.isSafeInteger()`** 静态方法判断提供的值是否是一个*安全整数*。

安全整数由 -(253 - 1) 到 253 - 1 的所有整数组成，包含（±9,007,199,254,740,991）。安全整数是符合以下条件的整数：

- 可以精确地表示为 IEEE-754 双精度数，并且
- 其 IEEE-754 表示形式不能是舍入任何其他整数以适应 IEEE-754 表示形式的结果。

例如，253 - 1 是一个安全整数：它可以精确地表示，并且在任何 IEEE-754 舍入模式下都没有其他整数舍入结果为该整数。相比之下，253 *不是*一个安全整数：它可以在 IEEE-754 中精确地表示，但整数 253 + 1 不能直接在 IEEE-754 中表示，而是采用就近舍入和向零舍入时，会舍入到 253。

处理大约 9 千万亿左右的值时，需要使用[任意精度算术库](https://zh.wikipedia.org/wiki/高精度计算)来实现完全精确性。有关浮点数表示的更多信息，请参阅[程序员需要了解的浮点数算术知识](https://floating-point-gui.de/)。

对于更大的整数，请考虑使用 [`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 类型。

## 76、什么是安全整数，如何判断一个整数是安全整数

2**53 - 1

## 77、字符串大写转小写

在 ES6+ 中，可直接使用原生 API `String.prototype.toLowerCase()` 实现

## 78、Array 中那些 API 可改变自身

增删改 push，pop，shift，unshift，splice

反转、排序

## 79、如何把一个数组 Array 转化为迭代器 Iterable

```javascript
const list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const it = list[Symbol.iterator]();

it.next();
```

## 80、Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么

![img](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)

Number中的最大数为2**1024 - 1

最大安全数是(2**53) - 1

EPSILON 是2**(-52)

## 81、反码和补码

原码、反码、补码是计算机中对数字的二进制表示方法。

原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。

总结：正数的原码、反码、补码完全一样，只有负数需要按照以上规则计算。

示例：

| 数值 | 原码       | 反码       | 补码       |
| ---- | ---------- | ---------- | ---------- |
| 6    | 0 000 0110 |            |            |
| -6   | 1 000 0110 | 1 111 1001 | 1 111 1010 |
| -128 | 1 000 0000 | 1 111 1111 | 1 000 0000 |

*示例中均为8-bit的整数。它的可表示范围包括-128到127，总共256（=2^8）个整数。

*0的反码、补码都为0

## 82、如何遍历一个对象

1. for in
2. object.keys()
3. object.entries()
4. 普通对象可以通过添加一个`Symbol.iterator`属性，实现使用 `for of` 遍历

```javascript

const obj = { a: 1, b: 2, c: 3, d: 4, e: 5 }
// 如果直接使用for...of会报错
// 给对象添加 Symbol.iterator 属性
obj[Symbol.iterator] = function () {
  // 通过this来获取对象
  const obj = this
  const keys = Object.keys(obj),
        len = keys.length
  let i = 0
  // 需要返回一个对象,这个对象需要有一个next方法
  return {
    next() {
      let result = null
      if (i < len) {
        result = { value: keys[i++], done: false }
      } else {
        result = { value: undefined, done: true }
      }
      return result
    },
  }
}
for (const key of obj) {
  console.log(key)
}
```

## 83、setTimeout为什么最小只能设置4ms，如何实现一个0ms的setTimeout?

### 总结

到这里，可以理解到, `setTimeout` 的 `4ms` 是如何被设定出来的。对于该方法的最小延迟我们可以有更加精确的定义。

1. 不同浏览器的最低时延会不一致，比如 chrome 的最低时延是 `1ms`。而如果 timer 嵌套层级很多，那么最低时延是 `4ms`。具体嵌套层级的阈值不同浏览器也不一致，HTML Standard 当中是 `>5`，chrome 当中是 `>=5`。

另外，我们也理解了在前面提到的两个问题：

1. 各大浏览器的厂商有没有按照规范实现，如果没有是为什么？
2. 4ms 这个数字究竟是如何确定的？

各大浏览器厂商没有完全按照规范实现，是由于其各自有各自的 benchmark，然后不同浏览器厂商做出了不同的设定。另外，对于这种影响不大的变量，HTML standard 提供了相应的灵活变动。我们也理解了 `4ms` 产生的背景以及背后浏览器厂商和操作系统厂商的不同考虑，他们各自做出的方案决策和 tradeoff。

## 84、return promise 与 return await promise 有何区别

```javascript
async function p1() {
  return 3;
}

async function p2() {
  return Promise.resolve(3);
}

async function p3() {
  return await Promise.resolve(3);
}

// Output: p1、p3、p2
p3().then((o) => console.log(o, "p3"));
p2().then((o) => console.log(o, "p2"));
p1().then((o) => console.log(o, "p1"));
```

涉及到`async ... await`的原理，上面的代理相当于如下代码

```javascript
// 此函数需要接受一个gen函数作为参数
function autoGenerator(gen) {
  // 此函数返回一个函数
  return function () {
    // async函数调用会返回一个promise对象
    return new Promise((resolve, reject) => {
      // 通过这个generator实例类进行next的调用
      const g = gen()
      // 定义一个自动调用next方法的函数,需要传递一个值,用于这个generator指针对象的返回值
      const autoNext = context => {
        // 获取next的值,yield后面调用的函数通过next来传递参数
        const { value, done } = g.next(context) // 最后一次next的值是由generator的返回值确定的
        // 判断是否已经执行完成
        if (done) {
          console.log('autoGenerator', { value, done })
          return resolve(value)
        } else {
          // 继续调用
          return Promise.resolve(value).then(
            res => autoNext(res),
            err => autoNext(err),
          )
        }
      }
      autoNext()
    })
  }
}

function* genP1() {
  return 1
}
function* genP2() {
  return Promise.resolve(2)
}
function* genP3() {
  const result = yield Promise.resolve(3)
  return result
}

const p3 = autoGenerator(genP3)
const p2 = autoGenerator(genP2)
const p1 = autoGenerator(genP1)
```

`p1`相当于

```javascript
const p1 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  resolve(1)
})
```

`p2`相当于

```javascript
const p2 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  resolve(Promise.resolve(2))
})
```

`p3`相当于

```javascript
const p3 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  Promise.resolve(3).then(resolve)
})
```

由于`resolve`在处理`promise`对象的时候是使用双`then`进行处理，相当于

```javascript
const p2 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  Promise.resolve(2).then().then(resolve)
})
```

所以最终输出的结果是：`p1、p3、p2`

## 85、在 ES6 Class 中，super 的过程中做了什么

```javascript
class Super {
  constructor() {
    //do something
  }
}
class Sub extends Super {
  constructor() {
    super();
    //do something else
  }
}
//=========等价于=========
function Super() {
  //do something
}
function Sub() {
  Sub.prototype.__proto__ = Super.prototype; //extends
  Super.call(this); //constructor中的super
  //但是其实这个地方严格讲是有问题的
  //在使用ES6 class的时候，constructor并不负责创建成员函数
  //但是在用Constructor function时，一个function要管所有的
  //成员变量和函数的创建。
  //而Super里的所有东西都释放到当前上下文this中是不合适的
  //会出现命名冲突之类的
  //babel的具体的实现要比这个复杂很多。
  //do something else
}``
```

## 86、如何取得一个数字的小数部分与整数部分

