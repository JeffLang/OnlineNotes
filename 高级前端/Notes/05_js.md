## 01、什么是防抖和节流，他们的应用场景有哪些

### 防抖(debounce)

触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

示例代码

```javascript
// 防抖: 高频事件n秒内只执行一次，结果是返回一个新的函数进行处理
function debounce(func, wait) {
  let timerId = 0
  return function () {
    // 进来就重新计时
    clearTimeout(timerId)
    // 保存this和参数
    const _this = this
    const args = arguments
    timerId = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
```

### 节流

针对高频事件n秒内只执行一次

示例代码

使用时间戳

```javascript
// 节流
function throttle(func, wait) {
  // 定义一个startTime
  let startTime = 0
  // 返回一个函数
  return function () {
    // 保存this和参数
    const _this = this
    const args = arguments
    // 记录本次的执行时间
    let nowTime = Date.now()
    // 判断,时间间隔达到之后在执行
    if (nowTime - startTime >= wait) {
      // 调用
      func.apply(_this, args)
      // 重置开始时间
      startTime = nowTime
    }
  }
}
```

使用定时器

```javascript
// 节流 定时器版本
function throttleTimer(func, wait) {
  let timerId = null
  return function () {
    const _this = this
    const args = arguments
    // 只有当没有定时器的时候才添加定时器
    if (!timerId) {
      timerId = setTimeout(() => {
        func.apply(_this, args)
        timerId = null
      }, wait)
    }
  }
}
```

## 02、手写Promise

```javascript
/*
            手写Promise

            思路

            */
// 定义三个状态的标记
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECT = 'reject'

class MyPromise {
  // 首先会生成一个promise对象
  // 定义一个私有状态变量,默认值为 pending
  #MyPromiseState = 'pending'
  // 定义一个返回结果 默认值为 undefined
  #MyPromiseResult = undefined

  // 定义一个保存then函数的数组,初始值为一个空的对象
  #ThenCallBackList = []
  // 定义一个保存去

  // 定义一个公共函数用来处理状态和结果,需要传入两个参数,state result
  #stateChange(state, result) {
    // 状态只能被修改一次,也就是说只能从pending
    if (this.#MyPromiseState !== PENDING) return
    this.#MyPromiseState = state
    this.#MyPromiseResult = result
    this.#run(state, result)
  }

  constructor(callBack) {
    // 定义resolve函数,调用该函数的时候,会修改promise对象的状态
    const resolve = data => {
      this.#stateChange(FULFILLED, data)
    }
    // 定义reject会修改promise的状态,
    const reject = result => {
      this.#stateChange(REJECT, result)
    }
    try {
      callBack(resolve, reject)
    } catch (error) {
      // 报错会直接调用reject
      console.error(`Uncaught (in myPromise) ${error}`)
      reject(error)
    }
  }

  // 定义一个run函数,用来执行then的回调
  #run(state, result) {
    // 从then回调列表中
    // 判断
    while (this.#ThenCallBackList.length) {
      const { onFulfilled, onReject, resolve, reject } = this.#ThenCallBackList.shift()
      try {
        // 执行这个函数,
        // 如果是fulfilled,执行onFulfilled
        if (state === FULFILLED) {
          resolve(onFulfilled(result))
        }
        // 如果是reject,执行onReject
        if (state === REJECT) {
          resolve(onReject(result))
        }
      } catch (error) {
        reject(error)
      }
    }
  }
  // 定义一个then函数
  // then函数
  // 1. then函数传入两个函数,第一个在resolve的时候调用,第二个在reject的时候调用
  // 2. then函数会返回一个promise
  then(onFulfilled, onReject) {
    return new MyPromise((resolve, reject) => {
      // 前一个promise resolve时调用onFulfilled
      if (this.#MyPromiseState === FULFILLED) {
        // then的回调是异步的
        setTimeout(() => {
          try {
            resolve(onFulfilled(this.#MyPromiseResult))
          } catch (error) {
            reject(error)
          }
        })
      }
      // 当前一个promise reject时,调用onReject
      if (this.#MyPromiseState === REJECT) {
        setTimeout(() => {
          try {
            resolve(onReject(this.#MyPromiseResult))
          } catch (error) {
            reject(error)
          }
        })
      }
      // 如果此时依然是pending状态,需要将这个传入一个then的回调队列中,等待到promise的状态确定之后在进行调用
      if (this.#MyPromiseState === PENDING) {
        // 把两个函数保存起来
        this.#ThenCallBackList.push({
          onFulfilled,
          onReject,
          resolve,
          reject,
        })
      }
    })
  }

  // 静态方法 resolve
  // 会返回一个promise对象,如果是Promise的实例,则调用该实例的then方法
  static resolve(value) {
    return new MyPromise((resolve, reject) => {
      // 如果是Promise对象,则调用这个promise对象的then方法
      if (value instanceof MyPromise) {
        // 调用这个thenable对象的then函数
        value.then(resolve, reject)
      } else {
        resolve(value)
      }
    })
  }

  // 静态方法 reject 返回一个拒绝的promise,不管是不是promise对象
  static reject(result) {
    return newMyPromise((_, reject) => {
      reject(result)
    })
  }

  // race方法,返回第一个完成的promise
  static race(promises) {
    return newMyPromise((resolve, reject) => {
      // 遍历传入的promise列表,因为只能执行一次,所以只会由第一个返回的promise状态
      promises.forEach(promise => {
        promise.then(result => resolve(result))
      })
    })
  }

  //Promise的静态方法，all
  static all(promises) {
    let values = []
    let i = 0
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        // 判断是否是promise
        if (promise instanceof MyPromise) {
          promise.then(
            value => {
              i++
              values[index] = value
              if (i >= promises.length) {
                resolve(values)
              }
            },
            result => {
              reject(result)
            },
          )
        } else {
          i++
          // 同步执行,肯定比上面快
          values[index] = promise
        }
      })
    })
  }
}
```

## 03、在前端开发中，如何获取浏览器的唯一标识

根据 `canvas` 可以获取浏览器指纹信息

1. 绘制 `canvas`，获取 `base64` 的 dataurl
2. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息

若在生产环境使用，可以使用 [fingerprintjs2(opens in a new tab)](https://github.com/Valve/fingerprintjs2)，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 `component`

## 04、js 中如何实现 bind

```javascript
// 手写apply,apply只是修改this
Function.prototype.myApply = function (context, ...args) {
  // 兼容性处理
  context = context || window
  // 保存this(函数本身)
  context.this = this
  // 调用
  const result = context.this(...args)
  delete context.this
  // 返回
  return result
}

// bind就是返回永久修改this的函数
Function.prototype.myBind = function (context, ...args) {
  const _this = this
  return function (...res) {
    return _this.myApply(context, [...args, ...res])
  }
}
```

## 05、js 中什么是 softbind，如何实现

```javascript
// bind就是返回永久修改this的函数
Function.prototype.mySoftBind = function (context, ...args) {
  const _this = this
  const bound = function (...res) {
    const newThis = !this || this === window ? context : this
    return _this.myApply(newThis, [...args, ...res])
  }
  bound.prototype = Object.create(_this.prototype)
  return bound
}
```

## 06、如何实现 promise.map，限制 promise 并发数

## 07、有没有用 npm 发布过 package，如何发布

1. 注册 npm 账号 [https://www.npmjs.com/(opens in a new tab)](https://www.npmjs.com/)
2. 本地通过命令行 `npm login` 登陆
3. 进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹

```json
{
  "name": "pkg-xxx",
  "version": "0.0.1",
  "main": "lib/index.js",
  "module": "esm/index.js",
  "typings": "types/index.d.ts",
  "files": [
    "CHANGELOG.md",
    "lib",
    "esm",
    "dist",
    "types",
  ],
  ...
}
```

执行 `npm publish --registry=https://registry.npmjs.org/` 即可发布

## 08、js 代码压缩 minify 的原理是什么

https://juejin.cn/post/7036169445550587940

## 09、关于 JSON，以下代码输出什么

对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉

## 10、在 js 中如何把类数组转化为数组

首先，什么是类数组(Array Like)？

**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**

那常见的类数组有哪些呢？

这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组

那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题

以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示

### ES6+

`ES6` 中有现成的 API：`Array.from`，极为简单

```javascript
// [undefined, undefined, undefined]
Array.from({ length: 3 });
```

除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值

拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代

```javascript
// 适用于 iterable 对象
[...document.querySelectorAll("div")];
```

但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常

```javascript
// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))[...{ length: 3 }];
```

### ES5

在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组

```javascript
const arrayLike = {  0: 3,  1: 4,  2: 5,  length: 3,};
```

在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。

最常见的转换是 `Array.prototype.slice`

```javascript
Array.prototype.slice.call(arrayLike);
```

**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**

- `Array` (借用 arguments)
- `Array.prototype.concat` (借用 arguments)
- `Array.prototype.slice` (借用 this)
- `Array.prototype.map` (借用 this)
- `Array.prototype.filter` (借用 this)

```javascript
Array.apply(null, arrayLike);
Array.prototype.concat.apply([], arrayLike);
Array.prototype.slice.call(arrayLike);
Array.prototype.map.call(arrayLike, (x) => x);
Array.prototype.filter.call(arrayLike, (x) => 1);
```

此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少

```javascript
// 该代码输出多少
Array(100).map((x) => 1);
```

> 参考 [Array(100).map(x =&gt; 1) 结果是多少(opens in a new tab)](https://github.com/shfshanyue/Daily-Question/issues/170)

### 稀疏数组 (sparse array)

使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示

`[,,,]` 与 `Array(3)` 都将返回稀疏数组

```javascript
> [,,,][empty × 3]> Array(3)[empty × 3]
```

当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组

### 总结

由上总结，把类数组转化成数组最靠谱的方式是以下三个

```javascript
Array.from(arrayLike);
Array.apply(null, arrayLike);
Array.prototype.concat.apply([], arrayLike);
```

以下几种方式需要考虑稀疏数组的转化

```javascript
Array.prototype.filter.call(divs, (x) => 1);
Array.prototype.map.call(arrayLike, (x) => x);
Array.prototype.filter.call(arrayLike, (x) => 1);
```

以下方法要注意是否是 `iterable object`

```javascript
[...arrayLike];
```

## 11、Array(100).map(x => 1) 结果是多少

`Array(100)` 将会创建一个稀疏数组 (sparse array)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`

```javascript
// [empty × 100]
Array(100);
```

正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`

**那如何生成100个元素为1的数组呢？**

可以使用 `Array.from`

```javascript
Array.from(Array(100), (x) => 1);
```

而在 `ES5` 中借用 `apply`

```javascript
Array.apply(null, Array(100)).map((x) => 1);
```

根据楼下提示，再添加一个 `fill`

```javascript
Array(100).fill(1);
```

## 12、如何在 url 中传递数组

转换为字符串在进行传递，或者是转成base64

## 13、compose函数

```javascript
const add10 = x => x + 10
const mul10 = x => x * 10
const add100 = x => x + 100

function compose1(...fns) {
  // 依次调用再返回
  return fns.reduce((a, b) => {
    return (...args) => {
      return a(b(...args))
    }
  })
}

function compose2(...fns) {
  return fns.reduce(
    (a, b) =>
    (...args) =>
    a(b(...args)),
  )
}

const fns = [add10, mul10, add100]

console.log(compose1(add10, mul10, add100)(10))
console.log(compose2(add10, mul10, add100)(10))
```

## 14、前端中遇到过处理二进制的场景吗

[JavaScript二进制数据处理(opens in a new tab)](http://coinfaces.me/posts/handling-binary-data-using-javascript/)

1. 读取二进制文件，绘制波形图。
2. 文件转储。下载文件，下载文件，后端返回二进制文件，前端进行处理并且下载

## 15、什么是 TypedArray

[ArrayBuffer，二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)

`ArrayBuffer` 是核心对象，是对固定长度的连续内存区域的引用。

几乎任何对 `ArrayBuffer` 的操作，都需要一个视图。

- 它可以是

  ```
  TypedArray
  ```

  ：

  - `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。
  - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。
  - `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。
  - `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。
- 或 `DataView` —— 使用方法来指定格式的视图，例如，`getUint8(offset)`。

在大多数情况下，我们直接对类型化数组进行创建和操作，而将 `ArrayBuffer` 作为“共同之处（common denominator）”隐藏起来。我们可以通过 `.buffer` 来访问它，并在需要时创建另一个视图。

还有另外两个术语，用于对二进制数据进行操作的方法的描述：

- `ArrayBufferView` 是所有这些视图的总称。
- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。

我们将在下一章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。

这是一份备忘单：

## 16、如何实现类似 lodash.get 函数

```javascript
function lodashGet(obj, path, defaultValue) {
  // 将a[3].b => a.3.b ,然后保存到数组中
  const paths = path.replace(/\[(\d+)\]/g, '.$1').split('.')
  // 层层迭代将
  const result = obj
  // 遍历paths依次拿值
  for (const key of paths) {
    result = Object(result)[key]
    if (result === undefined) {
      result = defaultValue
      break
    }
  }
  return result
}
```

## 17、js 中什么是可选链操作符，如何访问数组

`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。

```javascript
const o = {};

// 添加可选链之前
o && o.a && o.a.b && o.a.b.c && o.a.b.c.d;

// 添加可选链之后
o?.a?.b?.c?.d;
```

## 18、深拷贝

```javascript
// 深拷贝
function deepClone(obj, hash = new WeakMap()) {
  // 特殊值判断 null == undefined
  if (obj == null) return obj
  // Date,日期函数,正则等不拷贝
  if (obj instanceof Date) return obj
  if (obj instanceof RegExp) return obj
  if (typeof obj !== 'object') return obj
  if (has.get(obj)) return obj
  // 创建一个对象进行深拷贝
  const cloneObj = {}
  // 将当前对象保存到hash中
  hash.get(obj, cloneObj)
  for (const key in obj) {
    if (Object.hasOwnProperty.call(object, key)) {
      cloneObj[key] = deepClone(obj[key], hash)
    }
  }
  return cloneObj
}
```

## 19、event Loop

![image](https://user-images.githubusercontent.com/19162008/109372242-850c0980-78e3-11eb-8fe6-ecb15fa5e480.png)

heap（堆）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。 stack（栈）：函数调用形成了一个由若干帧组成的栈。 WebAPIS：囊括 Web 强大脚本能力的每个 API 参考资料， 包括 DOM 、所有相关的 APIs 及可以用来构建 Web 的相关接口。 队列（event queue || Callback Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数

[event loop 运行图解(opens in a new tab)](http://latentflip.com/loupe/?code=c2V0VGltZW91dChmdW5jdGlvbigpewogICAgY29uc29sZS5sb2coJzEnKQp9LDApOwoKbmV3oCBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpewoKoCBjb25zb2xlLmxvZygnMicpOwoKoCByZXNvbHZlKCk7Cgp9KS50aGVuKGZ1bmN0aW9uKCl7Cgpjb25zb2xlLmxvZygnMycpCgp9KTsKCmNvbnNvbGUubG9nKCc0Jyk7Cg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

```
setTimeout(() => {    console.log(1)}, 100)console.log(2);setTimeout(() => {    console.log(3)}, 0)// 2// 1// 3
```

![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif)

看图我们可以了解到，setTimeout(() => {console.log(1)}, 0) 会在Stack执行，在放入WebAPIs中当成一个匿名函数执行，匿名函数执行完毕之后会放入Callback Queue 中。 console.log(2) 则直接被推入Stack 中执行。

setTimeout(() => {console.log(3)}, 0) 同样的执行后放入WebAPIs中当成一个匿名函数执行，在放入Callback Queue中。当同步任务执行完之后，才会将Callback Queue 队列中的方法推入Stack中。

**因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。 所有同步任务都在主线程上执行，形成一个Stac）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才回读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。**

**这就是EventLoop**

## 20、flatMap实现

```javascript
// 先map再flat
const myFlatMap = function (fn) {
  const arr = this
  return arr.map(fn).flat(1)
}
```

## 21、裁切图片

```javascript
// 图片裁剪
function clipImage() {
  var path = 'https://static-zh.wxb.com.cn/customer/form/2020/11/1758696796d.jpg'
  // 创建一个canvas
  const canvas = document.createElement('canvas')
  canvas.width = 400
  canvas.height = 400
  // 获取ctx对象
  const ctx = canvas.getContext('2d')
  const img = document.createElement('img')
  const img2 = document.createElement('img')
  img.crossOrigin = 'anonymous'
  img.src = path
  document.body.appendChild(img)
  img.onload = function () {
    // 前面4个是源图片的位置及大小，后面是绘制在canvas的位置及大小
    // 如果只写了四个位置参数，则代表的是将整图片绘制在canvas上的位置大小，
    ctx.drawImage(this, 0, 0, 200, 200, 0, 0, 200, 200)
    console.log(canvas.toDataURL())
    const path = canvas.toDataURL()
    img2.src = path
    document.body.appendChild(img2)
  }
}
```

## 22、如何使用 async/await 实现 Promise.all 的效果

```javascript
async function fn() {
  const req = i =>
  fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=${i}&q=is%3Aissue+is%3Aopen`, {
    mode: 'no-cors',
  })

  // promise.all
  const res = await Promise.all([req(1), req(2), req(3)])

  // await
  const res1 = req(4)
  const res2 = req(5)
  const res3 = req(6)
  const u1 = await res1
  const u2 = await res2
  const u3 = await res3
  }
fn()
```

## 23、有没有用过 Promise.allSettled() ，它是干什么的

接收一个可迭代对象，其中每个成员都是 `Promise`。在所有给定的 `Promise`都已经 `fulfilled`或 `rejected`后返回一个 `Promise`，并带有一个对象数组，每个对象表示对应的 `Promise`结果 相较于 `Promise.all`，后者会在任何一个 `Promise`为 `rejected`时立即结束 简单实现

## 24、如何查看你们 JS 项目中应采用的 node 版本

我不确定是指 一个完全新的从零开始的项目，还是指已有的项目相对于新人来说的刚接手的“新”。

1. 如果是一个完全新的从零开始的项目，一般来说，如果均是采用最新稳定版本的依赖包，那么可以采用的node版本，其范围可以确定在 `^14.18.0 || >=16` 不超过node的当前最新稳定版本；而如果由于项目的特殊性，采用了低版本的依赖包，那么需要查看这些包的 `package.json` 的 `engines.node` 以确定这些包支持的node版本，取交集后确定最终采用的node版本。
2. 如果是一个已有的项目，首先查看的是 项目的 `package.json` 中的 `engines.node` 字段，如果有声明，那么就采用对应的版本，如果没有，那么直接询问该项目的原负责人，确认是否有 node 版本的要求以及应该使用哪个版本，负责人不确定就询问原先用于开发或构建这个项目的机器安装的 node 版本，这样可以保证切换到新人的开发机器上，也有一致的node环境。

## 25、简述 node/v8 中的垃圾回收机制

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。 要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。 **代际假说（The Generational Hypothesis）**，是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。 代际假说有以下两个特点：

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
2. 是不死的对象，会活得更久。 在 V8 中 会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。 ● **副垃圾回收器**，主要负责新生代的垃圾回收。 ● 主垃圾回收器，主要负责老生代的垃圾回收。

全停顿![1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f](https://user-images.githubusercontent.com/19986739/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png)

增量标记![1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97](https://user-images.githubusercontent.com/19986739/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，增强用户体验。

参考： [浏览器工作原理与实践](https://time.geekbang.org/column/article/131233)

### JavaScript的内存管理

### 内存回收机制（GC）

Javascript的V8引擎被限制了内存的使用，因此根据不同操作系统的内存大小会不一样。

V8引擎最初设计是作为浏览器的引擎，并未考虑占据过多的内存空间，随着web技术工程化的发展，占据了越来越多的内存空间。又由于被v8的会回收机制所限制，这样就引起了js执行的线程被挂起，会影响当前执行的页面应用性能。

**垃圾回收算法：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清除或释放内存。** 但是垃圾回收算法是个不完美的方案，因为某块内存是否还可用，属于不可预判的问题，也就意味着单纯依靠算法是解决不了的。还有为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了。

我们知道了垃圾是如何产生的，那么我们应该如何清除呢？在浏览器的发展历史上有两种解决策略：

- 标记清除
- 引用计数

不管什么程序语言，内存生命周期基本是一致的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放归还

与其他需要手动管理内存的语言不通，在JavaScript中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。

```javascript
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存

var o = {
  a: 1,
  b: null
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "abra"]; 

function f(a){
  return a + 2;
} // 给函数（可调用的对象）分配内存

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

当系统发现这些变量不再被使用的时候，会自动释放（垃圾回收）这些变量的内存，开发者不用过多的关心内存问题。

虽然这样，我们开发过程中也需要了解JavaScript的内存管理机制，这样才能避免一些不必要的问题，比如下面代码：

```javascript
{}=={} // false
[]==[] // false
''=='' // true
```

在JavaScript中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。

- 基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的
- 引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。

而对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放。而堆空间中的内存，由于大小不固定，系统无法无法进行自动释放，这个时候就需要JS引擎来手动的释放这些内存。

#### 为什么需要垃圾回收

在Chrome中，v8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制呢？

1. 表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景
2. 深层原因是，V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）

前面说到栈内的内存，操作系统会自动进行内存分配和内存释放，而堆中的内存，由JS引擎（如Chrome的V8）手动进行释放，当我们的代码没有按照正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露），从而使得浏览器占用的内存不断增加，进而导致JavaScript和应用、操作系统性能下降。

#### Chrome 垃圾回收算法

在JavaScript中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收。为了提高回收效率，V8 将堆分为两类`新生代`和`老生代`，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。
- 主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收。

##### 新生代垃圾回收器 - Scavenge

在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用`Scavenge`算法进行垃圾回收，`Scavenge`算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。

Scavange算法将新生代堆分为两部分，分别叫`from-space`和`to-space`，工作方式也很简单，就是将`from-space`中存活的活动对象复制到`to-space`中，并将这些对象的内存有序的排列起来，然后将`from-space`中的非活动对象的内存进行释放，完成之后，将`from space` 和`to space`进行互换，这样可以使得新生代中的这两块区域可以重复利用。

![img](https://segmentfault.com/img/remote/1460000025129639)

简单的描述就是：

- 标记活动对象和非活动对象
- 复制 from space 的活动对象到 to space 并对其进行排序
- 释放 from space 中的非活动对象的内存
- 将 from space 和 to space 角色互换

那么，垃圾回收器是怎么知道哪些对象是活动对象和非活动对象的呢？

有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。

新生代中的对象什么时候变成老生代的对象呢？

在新生代中，还进一步进行了细分，分为`nursery`子代和`intermediate`子代两个区域，一个对象第一次分配内存时会被分配到新生代中的`nursery`子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 `intermediate` 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。

##### 老生代垃圾回收 - Mark-Sweep（标记清除） & Mark-Compact（标记整理）

新生代空间中的对象满足一定条件后，晋升到老生代空间中，在老生代空间中的对象都已经至少经历过一次或者多次的回收所以它们的存活概率会更大，如果这个时候再使用`scavenge`算法的话，会出现两个问题：

- scavenge为复制算法，重复复制活动对象会使得效率低下
- scavenge是牺牲空间来换取时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题

所以在老生代空间中采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。

##### Mark-Sweep

Mark-Sweep处理时分为两阶段，标记阶段和清理阶段，看起来与Scavenge类似，不同的是，Scavenge算法是复制活动对象，而由于在老生代中活动对象占大多数，所以Mark-Sweep在标记了活动对象和非活动对象之后，直接把非活动对象清除。

- 标记阶段：对老生代进行第一次扫描，标记活动对象
- 清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象

![img](https://segmentfault.com/img/remote/1460000025129638)

看似一切 perfect，但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。

##### Mark-Compact

由于Mark-Sweep完成之后，老生代的内存中产生了很多内存碎片，若不清理这些内存碎片，如果出现需要分配一个大对象的时候，这时所有的碎片空间都完全无法完成分配，就会提前触发垃圾回收，而这次回收其实不是必要的。

为了解决内存碎片问题，Mark-Compact被提出，它是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。

![img](https://segmentfault.com/img/remote/1460000025129640)

##### 全停顿 Stop-The-World

由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为`全停顿`（stop-the-world）。

在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。

#### 优化 Orinoco

orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它利用了增量标记、懒性清理、并发、并行来降低主线程挂起的时间。

##### 增量标记 - Incremental marking

为了降低全堆垃圾回收的停顿时间，增量标记将原本的标记全堆对象拆分为一个一个任务，让其穿插在JavaScript应用逻辑之间执行，它允许堆的标记时的5~10ms的停顿。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。

![img](https://segmentfault.com/img/remote/1460000025129644)

##### 懒性清理 - Lazy sweeping

增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕。

增量标记与惰性清理的出现，使得主线程的最大停顿时间减少了80%，让用户与浏览器交互过程变得流畅了许多，从实现机制上，由于每个小的增量标价之间执行了JavaScript代码，堆中的对象指针可能发生了变化，需要使用`写屏障`技术来记录这些引用关系的变化，所以也暴露出来增量标记的缺点：

- 并没有减少主线程的总暂停的时间，甚至会略微增加
- 由于写屏障（Write-barrier）机制的成本，增量标记可能会降低应用程序的吞吐量

##### 并发 - Concurrent

并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行`写屏障`操作。

![img](https://segmentfault.com/img/remote/1460000025129641)

##### 并行 - Parallel

并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。

![img](https://segmentfault.com/img/remote/1460000025129642)

### V8当前垃圾回收机制

2011年，V8应用了增量标记机制。直至2018年，Chrome64和Node.js V10启动并发标记（Concurrent），同时在并发的基础上添加并行（Parallel）技术，使得垃圾回收时间大幅度缩短。

### 副垃圾回收器

V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从`from-to`复制到`space-to`的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。

![img](https://segmentfault.com/img/remote/1460000025129645)

### 主垃圾回收器

V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写入屏障（[write barriers](https://link.segmentfault.com/?enc=LdgFM4I7pLX1CbImGALMYw%3D%3D.3qngpaCxqq7ZZ1aeMQyAOJfp0jWP9gqdSjcOM0BScDyau44E%2BBmP7K7UoVUvJjwkE3%2Fgzc3dfTQxwcpuevyZHsymcf%2BKzJ8X31C7ZVlSnOg%3D)）技术会在辅助线程在进行并发标记的时候进行追踪。

当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。

![img](https://segmentfault.com/img/remote/1460000025129643)

### 结束

其实，大部分JavaScript开发人员并不需要考虑垃圾回收，但是了解一些垃圾回收的内部原理，可以帮助你了解内存的使用情况，根据内存使用观察是否存在内存泄露，而防止内存泄露，是提升应用性能的一个重要举措。

## 26、fetch 中 credentials 指什么意思，可以取什么值

`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`

- `omit`: 从不发送 `cookie`.
- `same-origin`: 同源时发送 `cookie` (浏览器默认值)
- `include`: 同源与跨域时都发送 `cookie`

## 27、如何删除项目中没有使用到的 package

```shell
$ npm install depcheck -g

$ depcheck
Unused dependencies
* underscore
Unused devDependencies
* jasmine
Missing dependencies
* lodash
```

## 28、如何实现 Promise.race

**`Promise.race()`** 静态方法接受一个 promise 可迭代对象作为输入，并返回一个 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。这个返回的 promise 会随着第一个 promise 的敲定而敲定。

## 29、js 中在 new 的时候发生了什么

1. 创建了一个新对象
2. 链接到原型
3. 绑定this指向4.返回这个对象

## 30、什么是 Iterable 对象，与 Array 有什么区别

- iterable对象是符合迭代器接口，可以通过 iterable.next()或者 for of 访问其中的元素
- Array是特殊的iterable对象，除了itearable的方式不遍历外，还 提供了 for in foreach map等方式

```javascript
// 数组的迭代器对象
const arr = [1, 2, 3, 4, 5]
let rangeArr = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  4: 5,
}

// 1. for..of 调用首先会调用这个：
rangeArr[Symbol.iterator] = function () {
  // 获取最多的迭代器的时常
  const keys = Object.keys(rangeArr)
  let i = 0
  let len = keys.length
  // ……它返回迭代器对象（iterator object）：
  // 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值
  return {
    // 3. next() 在 for..of 的每一轮循环迭代中被调用
    next() {
      // 4. 它将会返回 {done:.., value :...} 格式的对象
      if (i < len) {
        // return { done: false, value: { key: keys[i], value: rangeArr[keys[i++]] } } // 对象类的返回方法,
        return { done: false, value: rangeArr[keys[i++]] } // 数组类的返回方法
      } else {
        return { done: true }
      }
    },
  }
}

// arr[Symbol.iterator] = null // 如果执行此行,则arr也不能使用for...of进行遍历

for (const iterator of rangeArr) {
  console.log('iterator', iterator)
}

console.dir(arr[Symbol.iterator]().next()) // 可通过此方式访问next()

for (const iterator of arr) {
  console.log('iterator', iterator)
}
```

## 31、js 如何全部替代一个子串为另一个子串

如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag

```
const s = "foo foo foo";s.replce(/foo/g, "bar");
```

那如题中，**是否可以使用正则表达式来替代子串**

答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下

```
// 期待结果: 'AhelloX hello3 '> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')< "AAA"
```

而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`

```
> 'hello. hello. hello. '.split('hello. ').join('A')< "AAA"
```

真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中

```
String.prototype.replaceAll(); "aabbcc".replaceAll("b", ". 'aa..cc'
```

详细文档在 [String.prototype.replaceAll(opens in a new tab)](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)

### 总结(及直接答案)

两种办法

- `str.split('foo').join('bar')`
- `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好

正则表达式中有特殊字符的话，可以将其转译：

```javascript
>  'hello. helloX hello3 '.replace(new RegExp('hello\\. ', 'g'), 'A')
< "AhelloX hello3 "
```

## 32、js如何实现继承

有以下两种方法可实现继承

### `class`/`extends`

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  hello() {
    console.log("hello");
  }
}

class Dog extends Animal {
  constructor(name, say) {
    super(name);
    this.say = say;
  }
}
```

### `function`/`new`

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.hello = () => {
  console.log("hello");
};

function Dog(name, say) {
  // 01 继承属性
  Animal.call(this, name);
  this.say = say;
}

// 02 通过连接原型链完成继承
Dog.prototype = Object.create(Animal.prototype);

// 03 再加上 constructor
Dog.prototype.constructor = Dog;
// Reflect.defineProperty(Dog.prototype, "constructor", {
//  value: Dog,
//  enumerable: false, // 不可枚举
//  writable: true
// })
```

## 33、once函数

```javascript
function once(fn) {
  // 定义一个flag,判断是否调用过
  let flag = false
  const argsObj = {}
  // 会返回一个函数
  return function (...arg) {
    // 判断函数是否被执行了
    const key = JSON.stringify(arg)
    if (flag && argsObj[key]) return argsObj[key]
    flag = true
    return (argsObj[key] = fn.apply(this, arg))
  }
}
// 测试
function test() {
  console.log('test')
  return 1
}
let o = once(test)
console.log(o()) // test 1
console.log(o()) // 1
console.log(o()) // 1
```

## 34、纯函数

通过 `Object`构造函数创建或 `__proto__`是 `null`

`Object.create(null)`

## 35、累加器

```javascript
function sum(...args) {
  // 返回一个函数继续收集参数
  const fn = (...reset) => sum(...args, ...reset)
  // 这个函数拥有一个valueOf属性
  fn.valueOf = () => {
    return args.reduce((prev, now) => {
      return (prev += now)
    })
  }
  return fn
}
```

## 36、JS 如何实现一个同步的 sleep 函数

```javascript
const sleepSync = wait => {
  const endTime = Date.now() + wait
  while (Date.now() < endTime) {}
}
```

## 37、实现一个函数用来解析 URL 的 querystring

```javascript
// 使用正则来进行
function parseUrl(url = window.location.href) {
  // 获取search 是一个字符串,
  const search = url.match(/\?([^?/#:]+)#?/)?.[1]
  const params = search.split('&').reduce((prev, now) => {
    let [key, val] = now.split('=')
    // 转义
    key = decodeURIComponent(key)
    val = decodeURIComponent(val)
    // 判断是否有相同的参数
    if (prev[key] !== undefined) {
      prev[key] = [].concat(prev[key], val)
    } else {
      prev[key] = val
    }
    return prev
  }, {})
  }
```

一开始 `decodeURIComponent(url)`是否不妥，如果query string中的value带有 `=`等字符并且已经被 `encodeURIComponent`，如 `http://example.com?tag=test&title=1%2B1%3D2`中 `title=1+1=2`，使用parse解析的结果是错误的。使用 `params[k] = decodeURIComponent(v)`是不是更好

## 38、delay

```javascript
function delay1(func, seconds, ...args) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const p1 = Promise.resolve(func(...args))
      .then(resolve)
      .catch(reject)
      }, seconds)
  })
}
function delay2(func, seconds, ...args) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        resolve(func(...args))
      } catch (error) {
        reject(error)
      }
    }, seconds)
  })
}
```

## 39、如何实现一个 sample 函数，从数组中随机取一个元素

```javascript
Array.prototype.sample = function () {
  return this[Math.floor(Math.random() * this.length)];
};
```

## 40、浏览器的剪切板中如何监听复制事件

在HTML元素上

```html
<input oncopy="cb" />
```

在JS中获取具体元素

```javascript
document.querySelector("p").oncopy = cb;document.oncopy = cb;
```

或者

```javascript
document.querySelector("p").addEventListener("copy", cb);document.addEventListener("copy", cb);
```

## 41、JSONP 的原理是什么，如何实现

摘自山月的博客，原文地址: [https://shanyue.tech/code/jsonp/(opens in a new tab)](https://shanyue.tech/code/jsonp/)

### 一个正常的请求: JSON

正常发请求时，`curl` 示例:

```javascript
$ curl https://shanyue.tech/api/user?id=100
 
{
  "id": 100,
  "name": "shanyue",
  "wechat": "xxxxx" ,
  "phone": "183xxxxxxxx"
}
```

使用 `fetch` 发送请求，示例:

```javascript
const data = await fetch("https://shanyue.tech/api/user?id=100", {
  headers: {
    "content-type": "application/json",
  },
  method: "GET",
}).then((res) => res.json());
```

请求数据后，使用一个函数来处理数据

```javascript
handleData(data);
```

### 一个 JSONP 请求

`JSONP`，全称 `JSON with Padding`，为了解决跨域的问题而出现。虽然它只能处理 GET 跨域，虽然现在基本上都使用 CORS 跨域，但仍然要知道它，毕竟**面试会问**。

`JSONP` 基于两个原理:

1. 动态创建 `script`，使用 `script.src` 加载请求跨过跨域
2. `script.src` 加载的脚本内容为 JSONP: 即 `PADDING(JSON)` 格式

从上可知，使用 `JSONP` 跨域同样需要服务端的支持。`curl` 示例

```javascript
$ curl https://shanyue.tech/api/user?id=100&callback=padding

padding({
  "id": 100,
  "name": "shanyue",
  "wechat": "xxxxx",
  "phone": "183xxxxxxxx"
})
```

对于正常的请求有何不同一目了然: **多了一个 callback=padding, 并且响应数据被 padding 包围**，这就是 JSONP

**那请求数据后，如何处理数据呢？此时的 padding 就是处理数据的函数**。我们只需要在前端实现定义好 padding 函数即可

```javascript
window.padding = handleData;
```

基于以上两个原理，这里实现一个简单 jsonp 函数：

```javascript
function jsonp_simple({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、默认 callback 函数为 padding
  script.src = `${url}?${stringify({ callback: "padding", ...params })}`;

  // 二、使用 onData 作为 window.padding 函数，接收数据
  window["padding"] = onData;

  // 三、动态加载脚本
  document.body.appendChild(script);
}

// 发送 JSONP 请求
jsonp_simple({
  url: "http://localhost:10010",
  params: { id: 10000 },
  onData(data) {
    console.log("Data:", data);
  },
});
```

此时会有一个问题: **window.padding 函数会污染全局变量，如果有多个 JSONP 请求发送如何处理？**

**使 jsonp 的回调函数名作为一个随机变量，避免冲突**，代码如下

```javascript
function jsonp({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、为了避免全局污染，使用一个随机函数名
  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`;

  // 二、默认 callback 函数为 cbFnName
  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`;

  // 三、使用 onData 作为 cbFnName 回调函数，接收数据
  window[cbFnName] = onData;

  document.body.appendChild(script);
}

// 发送 JSONP 请求
jsonp({
  url: "http://localhost:10010",
  params: { id: 10000 },
  onData(data) {
    console.log("Data:", data);
  },
});
```

#### 服务器端代码

`JSONP` 需要服务端进行配合，返回 `JSON With Padding` 数据，代码如下:

```javascript
const http = require("http");
const url = require("url");
const qs = require("querystring");

const server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url);
  const params = qs.parse(query);

  const data = { name: "shanyue", id: params.id };

  if (params.callback) {
    // 服务端将要返回的字符串
    str = `${params.callback}(${JSON.stringify(data)})`;
    res.end(str);
  } else {
    res.end();
  }
});

server.listen(10010, () => console.log("Done"));
```

#### 完整代码附录

完整代码可见[山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code): [https://github.com/shfshanyue/blog/tree/master/code/jsonp/(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code/jsonp/)

**JSONP 实现完整代码:**

```javascript
function stringify(data) {
  const pairs = Object.entries(data);
  const qs = pairs
  .map(([k, v]) => {
    let noValue = false;
    if (v === null || v === undefined || typeof v === "object") {
      noValue = true;
    }
    return `${encodeURIComponent(k)}=${noValue ? "" : encodeURIComponent(v)}`;
  })
  .join("&");
  return qs;
}

function jsonp({ url, onData, params }) {
  const script = document.createElement("script");

  // 一、为了避免全局污染，使用一个随机函数名
  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`;
  // 二、默认 callback 函数为 cbFnName
  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`;
  // 三、使用 onData 作为 cbFnName 回调函数，接收数据
  window[cbFnName] = onData;

  document.body.appendChild(script);
}
```

**JSONP 服务端适配相关代码:**

```javascript
const http = require("http");
const url = require("url");
const qs = require("querystring");

const server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url);
  const params = qs.parse(query);

  const data = { name: "shanyue", id: params.id };

  if (params.callback) {
    str = `${params.callback}(${JSON.stringify(data)})`;
    res.end(str);
  } else {
    res.end();
  }
});

server.listen(10010, () => console.log("Done"));
```

**JSONP 页面调用相关代码**

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title></title>
  </head>
  <body>
    <script src="./index.js" type="text/javascript"></script>
    <script type="text/javascript">
      jsonp({
        url: "http://localhost:10010",
        params: { id: 10000 },
        onData(data) {
          console.log("Data:", data);
        },
      });
    </script>
  </body>
</html>
```

### JSONP 实现代码示例演示

- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)
- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)
- 从中克隆代码: [山月博客的 github 仓库(opens in a new tab)](https://github.com/shfshanyue/blog/tree/master/code)

#### 文件结构

- `index.js`: jsonp 的简单与复杂实现
- `server.js`: 服务器接口形式
- `demo.html`: 前端如何调用 JSONP

#### 快速演示

```nginx
// 开启服务端
$ node server.js

// 对 demo.html 起一个服务，并且按照提示在浏览器中打开地址，应该是 http://localhost:5000
// 观察控制台输出 JSONP 的回调结果
$ serve .
```

## 42、v8是如何执行一段js代码的

### 参考几篇文章

- [V8是如何执行JavaScript代码的？](https://zhuanlan.zhihu.com/p/96502646)
- [[译\]JavaScript是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧](https://zhuanlan.zhihu.com/p/57898561)
- [JavaScript 引擎 V8 执行流程概述](https://zhuanlan.zhihu.com/p/111386872)

## 43、实现一个数组去重函数 unique

- 使用Set

```javascript
function unique(arr) {
  if (!Array.isArray(arr)) throw new TypeError();
  return [...new Set(arr)];
}
```

- 使用set

```javascript
// 使用Map方法
function unique2(arr) {
  // 判断,如果传的不是数组则需要直接返回
  if (!Array.isArray(arr)) return
  const map = new Map()
  // 使用map进行去重
  for (const val of arr) {
    map.set(val, val)
  }
  const list = []
  for (const val of map.keys()) {
    list.push(val)
  }
  return list
}
```

## 44、shuffle

使用以下算法可实现洗牌算法:

1. 第 N 项数字与前 N 项数字随机选一相互交换
2. 第 N-1 项数字与前 N-1 项数字随机选一相互交换
3. ...
4. 第 2 项数字与前 2 项数字随机选一相互交换

```javascript
// 从后面开始打乱
function shuffle1(list) {
  const len = list.length
  let result = [...list]
  for (let i = len - 1; i > 0; i--) {
    const swapIndex = Math.floor(Math.random() * (i + 1))
    console.log(i, swapIndex)
    ;[result[i], result[swapIndex]] = [result[swapIndex], result[i]]
  }
  return result
}

// 从前面开始打乱
function shuffle2(list) {
  const len = list.length
  let result = [...list]
  for (let i = 0; i < len - 1; i++) {
    // 选择从1到length选中一个进行交换
    const swapIndex = Math.floor(Math.random() * (len - (i + 1))) + (i + 1)
    ;[result[i], result[swapIndex]] = [result[swapIndex], result[i]]
  }
  return result
}
```

## 45、vue3 中，如何监听数组的变化

不需要额外监听，因为 Proxy 代理后的数据，数组的修改也是可以监听到的，reactive 之后直接修改即可。

let list = [] const listProxy = new Proxy(list, { set(target, property, value) { console.log('set', property, value) //property指下标 value值 target[property] = value return true //表示设置成功 } })

## 46、现代框架如 React、Vue 相比原生开发有什么优势

react、vue： 1、一套代码维护Android和ios两个平台，减少开发成本 2、相同功能可以使用组件复用 3、两个平台可以同时更新，原生代码更新时需要审核

## 47、typeof 与 instanceof 的区别

1. `typeof` 用以**判断基础数据类型** (null 除外)，对于引用数据类型，大部分都是返回的Object
2. `instanceOf` 借助原型链**判断复杂数据类型**，但是值不确定

`typeof` 能够准确检查除了 null 之外的基础数据类型(number, string, symbol, bigInt, undefined, boolean, null)

`instanceof` 的语义是检查操作符右边的函数原型是否存在于左边对象的原型链中

## 48、JS 如何翻转一个字符串

```javascript
const reverse = (s) => [...s].reduceRight((acc, cur) => acc + cur);
const reverse = (s) => s.split("").reverse().join("");
```

## 49、前端如何实现文件上传功能

```javascript
const uploadInput = document.getElementById("upload");
const handleUpload = (event) => {
  const file = event.target.files[0];
  const formData = new FormData();
  formData.append("file", file);
  // 文件上传操作
};
uploadInput.addEventListener("change", handleUpload);
```

## 51、Promise.all

```javascript
//Promise的静态方法，all,any正好相反
static all(promises) {
  let values = []
  let i = 0
  return new MyPromise((resolve, reject) => {
    promises.forEach((promise, index) => {
      // 判断是否是promise
      if (promise instanceof MyPromise) {
        promise.then(
          value => {
            i++
            values[index] = value
            if (i >= promises.length) {
              resolve(values)
            }
          },
          result => {
            reject(result)
          },
        )
      } else {
        i++
        // 同步执行,肯定比上面快
        values[index] = promise
      }
    })
  })
}
```

## 51、Promise.any

与Promise.all相反

## 52、如何过滤数组中的 falsy value

falsy value 包含：`false`, `null`, `0`, `""`, `undefined`, `NaN`

## 53、如何创建一个数组大小为100，每个值都为0的数组

```javascript
// 方法一:
Array(100).fill(0);

// 方法二:
// 注: 如果直接使用 map，会出现稀疏数组
Array.from(Array(100), (x) => 0);

// 方法二变体:
Array.from({ length: 100 }, (x) => 0);
```

## 54、async await原理

### Generator

async/await为什么说是语法糖呢，是谁的语法糖呢？

在阮一峰的ES6入门教程中有说到：

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

> Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。
>
> 异步操作需要暂停的地方，都用 yield 语句注明
>
> 调用 Generator 函数，返回的是指针对象(这是它和普通函数的不同之处),。调用指针对象的 next 方法，会移动内部指针。
>
> next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

了解generator用法

```javascript
function* Generator() {
  yield "1";
  yield Promise.resolve(2);
  return "3";
}
var gen = Generator();
console.log(gen); //返回一个指针对象 Generator {<suspended>}
```

调用next方法

```javascript
let res1 = gen.next();
console.log(res1); // 返回当前阶段的值 { value: '1', done: false }

let res2 = gen.next();
console.log(res2); // 返回当前阶段的值 { value: Promise { 2 }, done: false }

res2.value.then((res) => {
  console.log(res); // 2
});

let res3 = gen.next();
console.log(res3); // { value: '3', done: true }

let res4 = gen.next();
console.log(res4); // { value: undefined, done: true }
```

### 实现async/await

**async/await的理解**

- **async 函数执行结果返回的是一个Promise**
- **async 函数就是将 Generator 函数的星号（\*）替换成 async，将 yield 替换成await**
- **async/await 就是 Generator 的语法糖，其核心逻辑是迭代执行next函数**

先来初步实现一个执行结果返回Promise的函数

先来初步实现一个执行结果返回Promise的函数

```javascript
function muYouAsync(){
      // 返回一个函数
    return function(){
          // 返回一个promise
        return new Promise((resolve, reject) => {

        })
    }
}
```

并且呢muYouAsync接受一个Generator函数作为参数的，那我们再来完善一下

```javascript
function* gen() {

}
//接受一个Generator函数作为参数
function muYouAsync(gen){
      // 返回一个函数
    return function(){
          // 返回一个promise
        return new Promise((resolve, reject) => {

        })
    }
}
```

我们来测试下看下执行结果是否返回Promise

```javascript
const asyncGen = muYouAsync(gen)
console.log(asyncGen()) //Promise {<pending>}
```

看输出结果的话与执行结果返回Promise是一致的

至此呢第一部分函数执行返回结果已完成，那我们来完善一下Generator函数

```javascript
const getFetch = (nums) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(nums + 1);
    }, 1000);
  });

function* gen() {
  let res1 = yield getFetch(1);
  let res2 = yield getFetch(res1);
  let res3 = yield getFetch(res2);
  return res3;
}
```

Generator函数也编写完成了，在下一步我们要想，怎么让它执行起来了呢，那就需要用到Generator核心逻辑迭代执行next函数，**注意点是需要将next迭代执行**

```javascript
//接受一个Generator函数作为参数
function muYouAsync(gen) {
  // 返回一个函数
  return function () {
    // 返回一个promise
    return new Promise((resolve, reject) => {
      // 执行Generator函数
      let g = gen();
      const next = (context) => {
        const { done, value } = g.next(context);
        if (done) {
          // 这时候说明已经是完成了，需要返回结果
          resolve(value);
        } else {
          // 继续执行next函数,传入执行结果
          return Promise.resolve(value).then(val => next(val))
        }
      };
      next();
    });
  };
}
```

整体的逻辑已经全都补充好了，那我们还需要在完善下最后一步，async返回的是promise，所以我们可以用try catch 来捕获

### 完整代码

```javascript
// 实现一个自动执行generator函数的方法

// 此函数需要接受一个gen函数作为参数
function autoGenerator(gen) {
  // 此函数返回一个函数
  return function () {
    // async函数调用会返回一个promise对象
    return new Promise((resolve, reject) => {
      // 通过这个generator实例类进行next的调用
      const g = gen()
      // 定义一个自动调用next方法的函数,需要传递一个值,用于这个generator指针对象的返回值
      const autoNext = context => {
        // 获取next的值,yield后面调用的函数通过next来传递参数
        const { value, done } = g.next(context) // 最后一次next的值是由generator的返回值确定的
        // 判断是否已经执行完成
        if (done) {
          return resolve(value)
        } else {
          // 继续调用
          return Promise.resolve(value).then(
            res => autoNext(res),
            err => autoNext(err),
          )
        }
      }
      autoNext()
    })
  }
}
```

那我们最后来测试一下

```javascript
const getFetch = (nums) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(nums + 1);
    }, 1000);
  });

function* gen() {
  let res1 = yield getFetch(1);
  let res2 = yield getFetch(res1);
  let res3 = yield getFetch(res2);
  return res3;
}

const asyncGen = muYouAsync(gen);
asyncGen().then(res => {console.log(res)}); // 4
```

## 55、Map 与 WeakMap 有何区别

`WeakMap `与 `Map `在 API 上的区别主要是两个，一是没有遍历操作（即没有 `keys()`、`values()`和 `entries()`方法），也没有 `size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 `clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`

## 56、Javascript 数组中有那些方法可以改变自身，那些不可以

不改变原数组的方法：concat/join/reduce/map/forEach/filter/slice/findIndex

改变原数组的方法：push/unshift/pop/shift/sort/splice/reverse

## 57、如何判断一个数组是否包含某个值

`Array.prototype.includes`

## 58、如何判断字符串包含某个子串

`String.prototype.includes();`

## 59、如何判断某一个值是数组

`const isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'`

## 60、简述 Object.defineProperty

与直接为一个对象的属性赋值(`o.a = 3`)不同，`Object.defineProperty` 可更为精确，拥有更多选项地为对象属性赋值

属性描述符拥有两种: 数据描述符与存取描述符

### 数据描述符 (data descriptor)

决定该属性值是否可写

```
const o = {};Object.defineProperty(o, "a", {  configurable: false,  enumerable: false,  writable: true,  value: 3,});
```

- `configurable`: 是否可被删除
- `enumerable`: 是否可被枚举，不可枚举属性无法通过 `Object.keys` 获取到
- `writable`: 是否可更改该属性值
- `value`: 该属性值的值

当我们使用赋值运算符为对象添加属性时，实际上是添加了一个数据描述符

```
> o.c = 5> Object.getOwnPropertyDescriptor(o, 'c')< {value: 5, writable: true, enumerable: true, configurable: true}
```

### 存取描述符 (accessor descriptor)

可对对象属性进行拦截，Vue2 的数据绑定原理便是基于此

```
const o = {};Object.defineProperty(o, "a", {  configurable: false,  enumerable: false,  get() {    return this._a;  },  set(a) {    this._a = a * 10;  },});
```

如果描述符没有 `value`、`writable`、`get` 和 `set` 键中的任何一个，它将被视为数据描述符。如果描述符同时具有 [`value` 或 `writable`] 和 [`get` 或 `set`] 键，则会抛出异常。

## 61、实现一个 inherits 函数进行继承

```javascript
function inherits(SuperType, SubType) {
  const pro = Object.create(SuperType.prototype);
  pro.constructor = SubType;
  SubType.prototype = pro;
}
function SuperType(friends) {
  this.friends = friends;
}
SuperType.prototype.getFriends = function () {
  console.log(this.friends);
};
function SubType(name, friends) {
  this.name = name;
  SuperType.call(this, friends);
}
inherits(SuperType, SubType);
SubType.prototype.getName = function () {
  console.log(this.name);
};

const tom = new SubType("tom", ["jerry"]);
tom.getName();
// 'tom'
tom.getFriends();
// ['jerry']
tom.friends.push("jack");
tom.getFriends();
// ['jerry', 'jack']
```

## 62、WeakMap 与垃圾回收有何关系

`WeakMap` 与 `Map` 有亮点不同

1. 键值只能为引用对象，无法使用基础数据类型
2. 弱引用，无法枚举，因此无 `.entries()` 方法

WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

## 63、什么是媒体查询，JS 可以监听媒体查询吗

![image](https://user-images.githubusercontent.com/101323067/188387499-1c5b9091-f7f6-40c0-98ca-e176ab474389.png)

js也支持媒体查询，window. matchMedia()方法，参考文章：[https://cloud.tencent.com/developer/article/2061082(opens in a new tab)](https://cloud.tencent.com/developer/article/2061082)

## 64、关于块级作用域，以下代码输出多少，在何时间输出

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000);}
```

一秒之后连续输出五个5，以下可输出预期效果

```
for (let i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000 * i);} for (var i = 0; i < 5; i++) {  setTimeout(console.log, 1000 * i, i);}
```

> 一秒之后连续输出五个5，以下可输出预期效果
>
> ```javascript
> for (let i = 0; i < 5; i++) {
>   setTimeout(() => console.log(i), 1000 * i);
> }
>  
> for (var i = 0; i < 5; i++) {
>   setTimeout(console.log, 1000 * i, i);
> }
> ```

为什么setTimeout格式不同,输出的结果也不同.例如:当for循环采用var声明变量,但setTimeout(console.log,1000*i,i)与setTimeout(()=>console.log(i),0)输出的结果不一样.

是因为函数作用域?

第一种使用var的方式:

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(() => console.log(i), 1000);}
```

第二种使用var的方式:

```javascript
for (var i = 0; i < 5; i++) {  setTimeout(console.log, 1000 * i, i);}
```

var 声明的变量是在函数作用域或者全局作用域的，在第一种方式中，由于setTimeout是异步执行，且它是从闭包中获取 i 变量，由于 i 是在函数/全局作用域中声明的，所以5次循环中 i 不断被赋值，最后 i 的值为5，执行的结果为连续的5个5。

在第二种方式中，通过给setTimeout的回调函数传参的方式，保存了每次循环中 i 的值，因此执行结果符合预期

let声明的变量是在块级作用域(花括号)中的，因此可以认为每次执行循环语句块中的 i 变量是互相独立的，所以执行结果也符合预期

## 65、关于块级作用域，以下代码输出多少，在何时间输出

可以直接调用 API 进行实现:

```javascript
const reverse = (s) => s.split("").reverse().join("");
 
reverse("hello");
//=> "olleh"
```

如果不调用 API 实现的话，参考以下代码:

```javascript
function reverse(s) {
  let r = "";
  for (const c of s) {
    r = c + r;
  }
  return r;
}
 
reverse("hello");
//=> "olleh"
```

## 66、为何 0.1+0.2 不等于 0.3，应如何做相等比较

0.1，0.2 表示为二进制会有精度的损失，比较时可引入一个很小的数值 `Number.EPSILON` 容忍误差

`Number.EPSILON` 是数字中 1 和可表示的比 1 大的最小数字之间的差值，因为[双精度浮点格式](https://zh.wikipedia.org/wiki/雙精度浮點數)只有 52 位来表示[尾数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_编码)，并且最低位的有效值为 2-52。

请注意，浮点数的绝对精度随着数字变大而降低，因为指数增长而尾数的精度保持不变。[`Number.MIN_VALUE`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE) 是可表示的最小正数，远小于 `Number.EPSILON`。

然而，对于任何具有更大数量级的算术运算，`Number.EPSILON` 是不适用的。如果你的数据数量级在 10**3 的范围，那么小数部分的精确度将远远小于 `Number.EPSILON`：

```javascript
function equal(x, y) {
  return Math.abs(x - y) < Number.EPSILON;
}

const x = 0.2;
const y = 0.3;
const z = 0.1;
console.log(equal(x + z, y)); // true
```

### 说说 Javascript 数字精度丢失的问题，如何解决？

`javaScript`存储方式是双精度浮点数，其长度为8个字节，即64位比特

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023，二进制1.0的指数位就是1023（转化为二进制）
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

如下图所示：

![594f0f0db0bd45779f3cfeb0147a9e46](https://static.developers.pub/594f0f0db0bd45779f3cfeb0147a9e46.png)

## 67、什么是纯函数

1. 输出仅由输入决定，每一个固定的输入总是返回相同的输出
2. 不产生副作用

```javascript
function push(list, x) {
  list.push(x);
  return list;
}

const l = [];
push(l, 3);
```

## 68、数字添加千分符

```javascript
function numberThousands(num, sign = ',') {
  return num.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, `$1${sign}`)
}
```

## 69、深比较deepEqual

```javascript
// 不光只判断对象的内存地址,还需要判断内部的内容是否相等
function deepEqual(x, y) {
  // 首先判断两个对象是都相等
  if (x === y) return true
  // 判断对象
  if (typeof x === 'object' && x !== null && typeof y === 'object' && y !== null) {
    // 进行递归比较
    // 先获取keys
    const xKeys = Object.keys(x)
    const yKeys = Object.keys(y)
    // 如果key的长度都不相等,肯定整个对象也不相等
    if (xKeys.length !== yKeys.length) return false
    // 遍历数组进行比较,只要遇到一个不相等则肯定不等
    for (const key of xKeys) {
      if (!deepEqual(x[key], y[key])) {
        return false
      }
    }
    // 如果整个for...of没找到不同,则返回true
    return true
  }
  console.log('else')
  return false
}
```

## 70、Object.is 与全等运算符(===)有何区别

Object.is()在===基础上特别处理了NaN,-0,+0，保证-0与+0不相等，但NaN与NaN相等

## 71、js 中什么是 AsyncIterable

```javascript
for await (const x of data) {
}
```

异步可迭代对象（Streams）

## 72、了解什么是 JSBridge 吗

而JSBridge是H5与Native的通信桥梁，他允许H5去调用原生的api（比如拍照、截屏、录屏等），极大的拓展了H5功能。

## 73、使用 JS 如何生成一个随机字符串

```javascript
// 生成随机字符串
function radomString(length = 32) {
  const str = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678',
        strLength = str.length
  let result = ''
  for (let index = 0; index < length; index++) {
    result += str.charAt(Math.random() * strLength)
  }
  return result
}
console.log(radomString())
```

## 74、Number.isNaN 与 globalThis.isNaN 有何区别

```javascript
// Number.isNaN 不会对数据进行类型转换
console.log('Number.isNaN', Number.isNaN('NaN')) // false

// globalThis.isNaN 会对数据进行类型转换
console.log('globalThis.isNaN', globalThis.isNaN('NaN')) // true
```

## 75、如何判断一个数值为整数

### Number.isFinite()

**`Number.isFinite()`** 静态方法判断传入值是否是一个有限数——也就是说，它检查给定值是一个数字，且该数字既不是正的 [`Infinity`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity)，也不是负的 `Infinity` 或 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。

### Number.isInteger()

**`Number.isInteger()`** 静态方法判断传入值是否为整数。

### Number.isSafeInteger()

**`Number.isSafeInteger()`** 静态方法判断提供的值是否是一个*安全整数*。

安全整数由 -(253 - 1) 到 253 - 1 的所有整数组成，包含（±9,007,199,254,740,991）。安全整数是符合以下条件的整数：

- 可以精确地表示为 IEEE-754 双精度数，并且
- 其 IEEE-754 表示形式不能是舍入任何其他整数以适应 IEEE-754 表示形式的结果。

例如，253 - 1 是一个安全整数：它可以精确地表示，并且在任何 IEEE-754 舍入模式下都没有其他整数舍入结果为该整数。相比之下，253 *不是*一个安全整数：它可以在 IEEE-754 中精确地表示，但整数 253 + 1 不能直接在 IEEE-754 中表示，而是采用就近舍入和向零舍入时，会舍入到 253。

处理大约 9 千万亿左右的值时，需要使用[任意精度算术库](https://zh.wikipedia.org/wiki/高精度计算)来实现完全精确性。有关浮点数表示的更多信息，请参阅[程序员需要了解的浮点数算术知识](https://floating-point-gui.de/)。

对于更大的整数，请考虑使用 [`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 类型。

## 76、什么是安全整数，如何判断一个整数是安全整数

2**53 - 1

## 77、字符串大写转小写

在 ES6+ 中，可直接使用原生 API `String.prototype.toLowerCase()` 实现

## 78、Array 中那些 API 可改变自身

增删改 push，pop，shift，unshift，splice

反转、排序

## 79、如何把一个数组 Array 转化为迭代器 Iterable

```javascript
const list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const it = list[Symbol.iterator]();

it.next();
```

## 80、Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么

![img](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)

Number中的最大数为2**1024 - 1

最大安全数是(2**53) - 1

EPSILON 是2**(-52)

## 81、反码和补码

原码、反码、补码是计算机中对数字的二进制表示方法。

原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。

总结：正数的原码、反码、补码完全一样，只有负数需要按照以上规则计算。

示例：

| 数值 | 原码       | 反码       | 补码       |
| ---- | ---------- | ---------- | ---------- |
| 6    | 0 000 0110 |            |            |
| -6   | 1 000 0110 | 1 111 1001 | 1 111 1010 |
| -128 | 1 000 0000 | 1 111 1111 | 1 000 0000 |

*示例中均为8-bit的整数。它的可表示范围包括-128到127，总共256（=2^8）个整数。

*0的反码、补码都为0

## 82、如何遍历一个对象

1. for in
2. object.keys()
3. object.entries()
4. 普通对象可以通过添加一个 `Symbol.iterator`属性，实现使用 `for of` 遍历

```javascript

const obj = { a: 1, b: 2, c: 3, d: 4, e: 5 }
// 如果直接使用for...of会报错
// 给对象添加 Symbol.iterator 属性
obj[Symbol.iterator] = function () {
  // 通过this来获取对象
  const obj = this
  const keys = Object.keys(obj),
        len = keys.length
  let i = 0
  // 需要返回一个对象,这个对象需要有一个next方法
  return {
    next() {
      let result = null
      if (i < len) {
        result = { value: keys[i++], done: false }
      } else {
        result = { value: undefined, done: true }
      }
      return result
    },
  }
}
for (const key of obj) {
  console.log(key)
}
```

## 83、setTimeout为什么最小只能设置4ms，如何实现一个0ms的setTimeout?

### 总结

到这里，可以理解到, `setTimeout` 的 `4ms` 是如何被设定出来的。对于该方法的最小延迟我们可以有更加精确的定义。

1. 不同浏览器的最低时延会不一致，比如 chrome 的最低时延是 `1ms`。而如果 timer 嵌套层级很多，那么最低时延是 `4ms`。具体嵌套层级的阈值不同浏览器也不一致，HTML Standard 当中是 `>5`，chrome 当中是 `>=5`。

另外，我们也理解了在前面提到的两个问题：

1. 各大浏览器的厂商有没有按照规范实现，如果没有是为什么？
2. 4ms 这个数字究竟是如何确定的？

各大浏览器厂商没有完全按照规范实现，是由于其各自有各自的 benchmark，然后不同浏览器厂商做出了不同的设定。另外，对于这种影响不大的变量，HTML standard 提供了相应的灵活变动。我们也理解了 `4ms` 产生的背景以及背后浏览器厂商和操作系统厂商的不同考虑，他们各自做出的方案决策和 tradeoff。

## 84、return promise 与 return await promise 有何区别

```javascript
async function p1() {
  return 3;
}

async function p2() {
  return Promise.resolve(3);
}

async function p3() {
  return await Promise.resolve(3);
}

// Output: p1、p3、p2
p3().then((o) => console.log(o, "p3"));
p2().then((o) => console.log(o, "p2"));
p1().then((o) => console.log(o, "p1"));
```

涉及到 `async ... await`的原理，上面的代理相当于如下代码

```javascript
// 此函数需要接受一个gen函数作为参数
function autoGenerator(gen) {
  // 此函数返回一个函数
  return function () {
    // async函数调用会返回一个promise对象
    return new Promise((resolve, reject) => {
      // 通过这个generator实例类进行next的调用
      const g = gen()
      // 定义一个自动调用next方法的函数,需要传递一个值,用于这个generator指针对象的返回值
      const autoNext = context => {
        // 获取next的值,yield后面调用的函数通过next来传递参数
        const { value, done } = g.next(context) // 最后一次next的值是由generator的返回值确定的
        // 判断是否已经执行完成
        if (done) {
          console.log('autoGenerator', { value, done })
          return resolve(value)
        } else {
          // 继续调用
          return Promise.resolve(value).then(
            res => autoNext(res),
            err => autoNext(err),
          )
        }
      }
      autoNext()
    })
  }
}

function* genP1() {
  return 1
}
function* genP2() {
  return Promise.resolve(2)
}
function* genP3() {
  const result = yield Promise.resolve(3)
  return result
}

const p3 = autoGenerator(genP3)
const p2 = autoGenerator(genP2)
const p1 = autoGenerator(genP1)
```

`p1`相当于

```javascript
const p1 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  resolve(1)
})
```

`p2`相当于

```javascript
const p2 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  resolve(Promise.resolve(2))
})
```

`p3`相当于

```javascript
const p3 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  Promise.resolve(3).then(resolve)
})
```

由于 `resolve`在处理 `promise`对象的时候是使用双 `then`进行处理，相当于

```javascript
const p2 = new Promise(resolve => {
  // resolve 处理一个promise的时候会进行异步的处理
  Promise.resolve(2).then().then(resolve)
})
```

所以最终输出的结果是：`p1、p3、p2`

## 85、在 ES6 Class 中，super 的过程中做了什么

```javascript
class Super {
  constructor() {
    //do something
  }
}
class Sub extends Super {
  constructor() {
    super();
    //do something else
  }
}
//=========等价于=========
function Super() {
  //do something
}
function Sub() {
  Sub.prototype.__proto__ = Super.prototype; //extends
  Super.call(this); //constructor中的super
  //但是其实这个地方严格讲是有问题的
  //在使用ES6 class的时候，constructor并不负责创建成员函数
  //但是在用Constructor function时，一个function要管所有的
  //成员变量和函数的创建。
  //而Super里的所有东西都释放到当前上下文this中是不合适的
  //会出现命名冲突之类的
  //babel的具体的实现要比这个复杂很多。
  //do something else
}``
```

## 86、如何取得一个数字的小数部分与整数部分
